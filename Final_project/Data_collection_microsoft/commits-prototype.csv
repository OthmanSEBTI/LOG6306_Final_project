sha,message,html_url,repository_id,repository_full_name,repository_private,repository_fork
f20063937a5b9279efc7e218f56e9f38cc5b0c9d,"Placeholders are Prototypes, given their design pattern",https://github.com/microsoft/WinObjC/commit/f20063937a5b9279efc7e218f56e9f38cc5b0c9d,37950166,microsoft/WinObjC,False,False
15827c5d306e007d7da0f97b34dbde7624f37b84,"Adds Block.prototype.mixin() and Blockly.Extensions.registerMixin(). (#907)//Adds Block.prototype.mixin() and Blockly.Extensions.registerMixin().//This adds support for a common use pattern in extensions, and adds//error checking to avoid future incompatibilities.",https://github.com/microsoft/pxt-blockly/commit/15827c5d306e007d7da0f97b34dbde7624f37b84,79385111,microsoft/pxt-blockly,False,False
b4d664f526fda6a151f5092bfeaf9c726698b1c6,"Don't require a name or version in ""project"" manifests. (#605)//* Don't require a name or version in ""project"" manifests.////In resolving https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1494960 ""[vcpkg ce] vcpkg-ce does not find vcpkg.json to find vcpkg-configuration.json"" I ran into a problem for existing vcpkg artifacts-only customers, where today they can name artifact dependencies without needing to supply a name or version. I want to be able to provide a reasonable ""how to fix it"" message for these customers and it seems reasonable to be able to declare dependencies without having a name or version. After some discussion with @ras0219-msft and @vicroms , the requirement for a name and version seems to be a historical artifact of using the same code to parse both port manifests and consumer/project manifests.////include/vcpkg/sourceparagraph.h://Rename parse_manifest_object to parse_port_manifest_object and add parse_project_manifest_object.////include/vcpkg/versiondeserializers.h://Declare visit_optional_schemed_deserializer (with static removed in the versiondeserializers.cpp)////include/vcpkg/versions.h://Add VersionScheme::Missing for the case that it isn't provided.////cmakevars.cpp://Use ""_manifest_"" as the ""port"" name when a name wasn't supplied for purposes of vcpkg_get_dep_info.////add.ps1://Add a new test of add port that uses an input manifest with no name or version information.////manifests.ps1://Remove name and version from the prototype manifest. Note that some of the tests still use a manifest with a name; in particular the ""self reference"" ones so we still have coverage of that.////format-manifest.ps1://Add project manifest examples in addition to the previous ""reserialize all ports"" test.////* Put the json entity type assert in the right place.////* Use JSON stuff rather than string stuff in the parsing tests.////* Invert template method pattern in manifest deserializer.////* Formatting////* Add overlay ports test.////* Add output asserts.",https://github.com/microsoft/vcpkg-tool/commit/b4d664f526fda6a151f5092bfeaf9c726698b1c6,319781556,microsoft/vcpkg-tool,False,False
b0e17a41be3b60e5ebcd42d25736ed331af4bda9,[X86-64] Fix incorrect function prototype discovery when the first use of an argument register is a tied-def./[Test] Add test to verify the fix./[Cleanup] Consolidate repeated code patterns.,https://github.com/microsoft/llvm-mctoll/commit/b0e17a41be3b60e5ebcd42d25736ed331af4bda9,152660616,microsoft/llvm-mctoll,False,False
b7d369280ba6073a285811733f90cf7f2e0066be,"[WebAssembly] Implement prototype SIMD rounding instructions//Summary:/As specified in https://github.com/WebAssembly/simd/pull/232. These/instructions are implemented as LLVM intrinsics for now rather than/normal ISel patterns to make these instructions opt-in. Once the/instructions are merged to the spec proposal, the intrinsics will be/replaced with proper ISel patterns.//Reviewers: aheejin//Subscribers: dschuff, sbc100, jgravelle-google, hiraditya, sunfish, cfe-commits, llvm-commits//Tags: #clang, #llvm//Differential Revision: https://reviews.llvm.org/D81222",https://github.com/microsoft/checkedc-clang/commit/b7d369280ba6073a285811733f90cf7f2e0066be,60645050,microsoft/checkedc-clang,False,False
1992e30c2d751f6f1f6ad5190f84e37dece04f7f,[WebAssembly] Prototype i8x16.popcnt//As proposed at https://github.com/WebAssembly/simd/pull/379. Use a target/builtin and intrinsic rather than normal codegen patterns to make the/instruction opt-in until it is merged to the proposal and stabilized in engines.//Differential Revision: https://reviews.llvm.org/D89446,https://github.com/microsoft/checkedc-clang/commit/1992e30c2d751f6f1f6ad5190f84e37dece04f7f,60645050,microsoft/checkedc-clang,False,False
7c6bfd90ab2ddaa60de62878c8512db0645e8452,"[WebAssembly] v128.load{8,16,32,64}_lane instructions//Prototype the newly proposed load_lane instructions, as specified in/https://github.com/WebAssembly/simd/pull/350. Since these instructions are not/available to origin trial users on Chrome stable, make them opt-in by only/selecting them from intrinsics rather than normal ISel patterns. Since we only/need rough prototypes to measure performance right now, this commit does not/implement all the load and store patterns that would be necessary to make full/use of the offset immediate. However, the full suite of offset tests is included/to make it easy to track improvements in the future.//Since these are the first instructions to have a memarg immediate as well as an/additional immediate, the disassembler needed some additional hacks to be able/to parse them correctly. Making that code more principled is left as future/work.//Differential Revision: https://reviews.llvm.org/D89366",https://github.com/microsoft/checkedc-clang/commit/7c6bfd90ab2ddaa60de62878c8512db0645e8452,60645050,microsoft/checkedc-clang,False,False
1a48caef667809dd31a47565fefbfbbe33ec4e39,"[SEH] Outline finally blocks using the new variable capture support//WinEHPrepare was going to have to pattern match the control flow merge/and split that the old lowering used, and that wasn't really feasible.//Now we can teach WinEHPrepare to pattern match this, which is much/simpler:/  %fp = call i8* @llvm.frameaddress(i32 0)/  call void @func(iN [01], i8* %fp)//This prototype happens to match the prototype used by the Win64 SEH/personality function, so this is really simple.//git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@234532 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/checkedc-clang/commit/1a48caef667809dd31a47565fefbfbbe33ec4e39,60645050,microsoft/checkedc-clang,False,False
0dbecf2b7816353329f58c91157670cd3e1e7b77,"[SEH] Outline finally blocks using the new variable capture support//WinEHPrepare was going to have to pattern match the control flow merge/and split that the old lowering used, and that wasn't really feasible.//Now we can teach WinEHPrepare to pattern match this, which is much/simpler:/  %fp = call i8* @llvm.frameaddress(i32 0)/  call void @func(iN [01], i8* %fp)//This prototype happens to match the prototype used by the Win64 SEH/personality function, so this is really simple.//llvm-svn: 234532",https://github.com/microsoft/checkedc-clang/commit/0dbecf2b7816353329f58c91157670cd3e1e7b77,60645050,microsoft/checkedc-clang,False,False
1a48caef667809dd31a47565fefbfbbe33ec4e39,"[SEH] Outline finally blocks using the new variable capture support//WinEHPrepare was going to have to pattern match the control flow merge/and split that the old lowering used, and that wasn't really feasible.//Now we can teach WinEHPrepare to pattern match this, which is much/simpler:/  %fp = call i8* @llvm.frameaddress(i32 0)/  call void @func(iN [01], i8* %fp)//This prototype happens to match the prototype used by the Win64 SEH/personality function, so this is really simple.//git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@234532 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/clang/commit/1a48caef667809dd31a47565fefbfbbe33ec4e39,29706297,microsoft/clang,False,False
c559e63798e69be1d7c66847b662b53ba88f0f9c,"Handle IntToPtr in isBytewiseValue//Summary:/This helps with more efficient use of memset for pattern initialization//From @pcc prototype for -ftrivial-auto-var-init=pattern optimizations//Binary size change on CTMark, (with -fuse-ld=lld -Wl,--icf=all, similar results with default linker options)/```/                   master           patch      diff/Os           8.238864e+05    8.238864e+05       0.0/O3           1.054797e+06    1.054797e+06       0.0/Os zero      8.292384e+05    8.292384e+05       0.0/O3 zero      1.062626e+06    1.062626e+06       0.0/Os pattern   8.579712e+05    8.338048e+05 -0.030299/O3 pattern   1.090502e+06    1.067574e+06 -0.020481/```//Zero vs Pattern on master/```/               zero       pattern      diff/Os     8.292384e+05  8.579712e+05  0.036578/O3     1.062626e+06  1.090502e+06  0.025124/```//Zero vs Pattern with the patch/```/               zero       pattern      diff/Os     8.292384e+05  8.338048e+05  0.003333/O3     1.062626e+06  1.067574e+06  0.003193/```//Reviewers: pcc, eugenis//Subscribers: hiraditya, cfe-commits, llvm-commits//Tags: #clang, #llvm//Differential Revision: https://reviews.llvm.org/D63967//llvm-svn: 365858",https://github.com/microsoft/checkedc-clang/commit/c559e63798e69be1d7c66847b662b53ba88f0f9c,60645050,microsoft/checkedc-clang,False,False
1d787d5cb799bed43282e6178a830ef186d4e5f7,"Move Loader Constructor to Props Pattern (#3945)//As part of some prototyping related to the version work, I saw the need to add another parameter to the loader constructor. I'm not sure what will come to fruition, as I'm continuing to explore a few designs. However, in looking at adding a new param i saw that the current constructor already takes several optional params, which is cumbersome, as each preceding optional param must be specified to specify the next. Moving the loader to a props pattern will make the loader easier to work with and construct.////Additionally, many of these same parameters are then passed to the container. I've simplified this to just pull the properties it needs directly from the load itself.",https://github.com/microsoft/FluidFramework/commit/1d787d5cb799bed43282e6178a830ef186d4e5f7,203843667,microsoft/FluidFramework,False,False
51c3ce7c564d4cf18dfc1594bd3a8efb29d5dc18,.NET adding internal cache prototype (perf improvement) (#1998)//* .NET adding internal cache prototype for speed (#1)////* Initial config normalization in English////* Add internal cache prototype////* Updated new Swedish recognizers and fixed Date cache experiment.////* Removing support for .NET Framework 4.5 and 4.5.2.////* Adding flag to disable internal cache.////* Fixing TurkishNumberRangeParserConfiguration to use Turkish number extractors.////* Making sure English number range passes Options internally.////* Moving cache keys to tuples. Making sure all datetime extractions receive reference time.////* Further improvements with cache reuse and key changes.////* Adding ISO 639-2 language codes to relevant pattern files////* Moving to standardize configs. Needs to be propagated to other languages.////* Reducing number of cache instances and propagating to Dutch.////* Centralizing number resultscache code and propagating configs to Chinese.////* Propagated configs and cache to Spanish and Portuguese numbers.////* Patch for other platforms after the language marker changes to match ISO////* Minor cleanup,https://github.com/microsoft/Recognizers-Text/commit/51c3ce7c564d4cf18dfc1594bd3a8efb29d5dc18,88544417,microsoft/Recognizers-Text,False,False
78de7297abe2e8fa782682168989c70e3cb34a5c,"Reland [AssumeBundles] Use operand bundles to encode alignment assumptions//NOTE: There is a mailing list discussion on this: http://lists.llvm.org/pipermail/llvm-dev/2019-December/137632.html//Complemantary to the assumption outliner prototype in D71692, this patch/shows how we could simplify the code emitted for an alignemnt/assumption. The generated code is smaller, less fragile, and it makes it/easier to recognize the additional use as a ""assumption use"".//As mentioned in D71692 and on the mailing list, we could adopt this/scheme, and similar schemes for other patterns, without adopting the/assumption outlining.",https://github.com/microsoft/checkedc-clang/commit/78de7297abe2e8fa782682168989c70e3cb34a5c,60645050,microsoft/checkedc-clang,False,False
e65e677ee4eed83a31503b1a7db3fca56f617eae,[globalisel][legalizer] Fix DebugLoc bugs caught by a prototype lost-location verifier//The legalizer has a tendency to lose DebugLoc's when expanding or/combining instructions. The verifier that detected these isn't ready/for upstreaming yet but this patch fixes the cases that came up when/applying it to our out-of-tree backend's CodeGen tests.//This pattern comes up a few more times in this file and probably in/the backends too but I'd prefer to fix the others separately (and/preferably when the lost-location verifier detects them).,https://github.com/microsoft/checkedc-clang/commit/e65e677ee4eed83a31503b1a7db3fca56f617eae,60645050,microsoft/checkedc-clang,False,False
7a85e3585ec59b1bfe3b08072ff042af80d07f22,"[ARM,CDE] Implement GPR CDE intrinsics//Summary:/This change implements ACLE CDE intrinsics that translate to/instructions working with general-purpose registers.//The specification is available at/https://static.docs.arm.com/101028/0010/ACLE_2019Q4_release-0010.pdf//Each ACLE intrinsic gets a corresponding LLVM IR intrinsic (because/they have distinct function prototypes). Dual-register operands are/represented as pairs of i32 values. Because of this the instruction/selection for these intrinsics cannot be represented as TableGen/patterns and requires custom C++ code.//Reviewers: simon_tatham, MarkMurrayARM, dmgreen, ostannard//Reviewed By: MarkMurrayARM//Subscribers: kristof.beyls, hiraditya, danielkiss, cfe-commits//Tags: #clang//Differential Revision: https://reviews.llvm.org/D76296",https://github.com/microsoft/checkedc-clang/commit/7a85e3585ec59b1bfe3b08072ff042af80d07f22,60645050,microsoft/checkedc-clang,False,False
05654971781ffd083c40d2115b81db7b8334c10f,"Teach getTemplateInstantiationPattern to deal with generic lambdas.//No functionality change.//When determining the pattern for instantiating a generic lambda call operator specialization - we must not go drilling down for the 'prototype' (i.e. as written) pattern - rather we must use our partially transformed  pattern (whose DeclRefExprs are wired correctly to any enclosing lambda's decls that should be mapped correctly in a local instantiation scope) that is the templated pattern of the specialization's primary template (even though the primary template might be instantiated from a 'prototype' member-template).  Previously, the drilling down was haltted by marking the instantiated-from primary template as a member-specialization (incorrectly). //This prompted Richard to remark (http://llvm-reviews.chandlerc.com/D1784?id=4687#inline-10272) /""It's a bit nasty to (essentially) set this bit incorrectly. Can you put the check into getTemplateInstantiationPattern instead?""//In my reckless youth, I chose to ignore that comment.  With the passage of time, I have come to learn the value of bowing to the will of the angry Gods ;) /////git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@205543 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/checkedc-clang/commit/05654971781ffd083c40d2115b81db7b8334c10f,60645050,microsoft/checkedc-clang,False,False
b90b211eea7274bba1588e86695a55bdd6490b5b,"Teach getTemplateInstantiationPattern to deal with generic lambdas.//No functionality change.//When determining the pattern for instantiating a generic lambda call operator specialization - we must not go drilling down for the 'prototype' (i.e. as written) pattern - rather we must use our partially transformed  pattern (whose DeclRefExprs are wired correctly to any enclosing lambda's decls that should be mapped correctly in a local instantiation scope) that is the templated pattern of the specialization's primary template (even though the primary template might be instantiated from a 'prototype' member-template).  Previously, the drilling down was haltted by marking the instantiated-from primary template as a member-specialization (incorrectly). //This prompted Richard to remark (http://llvm-reviews.chandlerc.com/D1784?id=4687#inline-10272) /""It's a bit nasty to (essentially) set this bit incorrectly. Can you put the check into getTemplateInstantiationPattern instead?""//In my reckless youth, I chose to ignore that comment.  With the passage of time, I have come to learn the value of bowing to the will of the angry Gods ;) //llvm-svn: 205543",https://github.com/microsoft/checkedc-clang/commit/b90b211eea7274bba1588e86695a55bdd6490b5b,60645050,microsoft/checkedc-clang,False,False
05654971781ffd083c40d2115b81db7b8334c10f,"Teach getTemplateInstantiationPattern to deal with generic lambdas.//No functionality change.//When determining the pattern for instantiating a generic lambda call operator specialization - we must not go drilling down for the 'prototype' (i.e. as written) pattern - rather we must use our partially transformed  pattern (whose DeclRefExprs are wired correctly to any enclosing lambda's decls that should be mapped correctly in a local instantiation scope) that is the templated pattern of the specialization's primary template (even though the primary template might be instantiated from a 'prototype' member-template).  Previously, the drilling down was haltted by marking the instantiated-from primary template as a member-specialization (incorrectly). //This prompted Richard to remark (http://llvm-reviews.chandlerc.com/D1784?id=4687#inline-10272) /""It's a bit nasty to (essentially) set this bit incorrectly. Can you put the check into getTemplateInstantiationPattern instead?""//In my reckless youth, I chose to ignore that comment.  With the passage of time, I have come to learn the value of bowing to the will of the angry Gods ;) /////git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@205543 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/clang/commit/05654971781ffd083c40d2115b81db7b8334c10f,29706297,microsoft/clang,False,False
6511c8bb9a7edb0f973b7ba5ca47f4ff049b1bc8,"[WinEH] Use llvm.x86.seh.recoverfp in WinEHPrepare//Don't pattern match for frontend outlined finally calls on non-x64/platforms. The 32-bit runtime uses a different funclet prototype.  Now,/the frontend is pre-outlining the finally bodies so that it ends up/doing most of the heavy lifting for variable capturing. We're just/outlining the callsite, and adapting the frameaddress(0) call to line up/the frame pointer recovery.//llvm-svn: 241186",https://github.com/microsoft/checkedc-clang/commit/6511c8bb9a7edb0f973b7ba5ca47f4ff049b1bc8,60645050,microsoft/checkedc-clang,False,False
8d09f20798ac180b1749276bff364682ce0196ab,"[AssumeBundles] Use operand bundles to encode alignment assumptions//Summary:/NOTE: There is a mailing list discussion on this: http://lists.llvm.org/pipermail/llvm-dev/2019-December/137632.html//Complemantary to the assumption outliner prototype in D71692, this patch/shows how we could simplify the code emitted for an alignemnt/assumption. The generated code is smaller, less fragile, and it makes it/easier to recognize the additional use as a ""assumption use"".//As mentioned in D71692 and on the mailing list, we could adopt this/scheme, and similar schemes for other patterns, without adopting the/assumption outlining.//Reviewers: hfinkel, xbolva00, lebedev.ri, nikic, rjmccall, spatel, jdoerfert, sstefan1//Reviewed By: jdoerfert//Subscribers: thopre, yamauchi, kuter, fhahn, merge_guards_bot, hiraditya, bollu, rkruppe, cfe-commits, llvm-commits//Tags: #clang, #llvm//Differential Revision: https://reviews.llvm.org/D71739",https://github.com/microsoft/checkedc-clang/commit/8d09f20798ac180b1749276bff364682ce0196ab,60645050,microsoft/checkedc-clang,False,False
c95ffadb2474a4d8c4f598d94d35a9f31d9606cb,"[AssumeBundles] Use operand bundles to encode alignment assumptions//Summary:/NOTE: There is a mailing list discussion on this: http://lists.llvm.org/pipermail/llvm-dev/2019-December/137632.html//Complemantary to the assumption outliner prototype in D71692, this patch/shows how we could simplify the code emitted for an alignemnt/assumption. The generated code is smaller, less fragile, and it makes it/easier to recognize the additional use as a ""assumption use"".//As mentioned in D71692 and on the mailing list, we could adopt this/scheme, and similar schemes for other patterns, without adopting the/assumption outlining.//Reviewers: hfinkel, xbolva00, lebedev.ri, nikic, rjmccall, spatel, jdoerfert, sstefan1//Reviewed By: jdoerfert//Subscribers: yamauchi, kuter, fhahn, merge_guards_bot, hiraditya, bollu, rkruppe, cfe-commits, llvm-commits//Tags: #clang, #llvm//Differential Revision: https://reviews.llvm.org/D71739",https://github.com/microsoft/checkedc-clang/commit/c95ffadb2474a4d8c4f598d94d35a9f31d9606cb,60645050,microsoft/checkedc-clang,False,False
8a1df9b25f37be9fcd33624581d5dcc05f118e06,"[WinEH] Use llvm.x86.seh.recoverfp in WinEHPrepare//Don't pattern match for frontend outlined finally calls on non-x64/platforms. The 32-bit runtime uses a different funclet prototype.  Now,/the frontend is pre-outlining the finally bodies so that it ends up/doing most of the heavy lifting for variable capturing. We're just/outlining the callsite, and adapting the frameaddress(0) call to line up/the frame pointer recovery.//git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@241186 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/llvm/commit/8a1df9b25f37be9fcd33624581d5dcc05f118e06,29704274,microsoft/llvm,False,False
eadc8a81ef3df4c986bd9b0f6676e0e49646fa0f,"[MS] Emit vftable thunks for functions with incomplete prototypes//Summary:/The following class hierarchy requires that we be able to emit a/this-adjusting thunk for B::foo in C's vftable://  struct Incomplete;/  struct A {/    virtual A* foo(Incomplete p) = 0;/  };/  struct B : virtual A {/    void foo(Incomplete p) override;/  };/  struct C : B { int c; };//This TU is valid, but lacks a definition of 'Incomplete', which makes it/hard to build a thunk for the final overrider, B::foo.//Before this change, Clang gives up attempting to emit the thunk, because/it assumes that if the parameter types are incomplete, it must be/emitting the thunk for optimization purposes. This is untrue for the MS/ABI, where the implementation of B::foo has no idea what thunks C's/vftable may require. Clang needs to emit the thunk without necessarily/having access to the complete prototype of foo.//This change makes Clang emit a musttail variadic call when it needs such/a thunk. I call these ""unprototyped"" thunks, because they only prototype/the ""this"" parameter, which must always come first in the MS C++ ABI.//These thunks work, but they create ugly LLVM IR. If the call to the/thunk is devirtualized, it will be a call to a bitcast of a function/pointer. Today, LLVM cannot inline through such a call, but I want to/address that soon, because we also use this pattern for virtual member/pointer thunks.//This change also implements an old FIXME in the code about reusing the/thunk's computed CGFunctionInfo as much as possible. Now we don't end up/computing the thunk's mangled name and arranging it's prototype up to/around three times.//Fixes PR25641//Reviewers: rjmccall, rsmith, hans//Subscribers: Prazek, cfe-commits//Differential Revision: https://reviews.llvm.org/D45112//git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@329009 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/checkedc-clang/commit/eadc8a81ef3df4c986bd9b0f6676e0e49646fa0f,60645050,microsoft/checkedc-clang,False,False
399d96e39c64f1fd3a00b78886a02abe58cdb36f,"[MS] Emit vftable thunks for functions with incomplete prototypes//Summary:/The following class hierarchy requires that we be able to emit a/this-adjusting thunk for B::foo in C's vftable://  struct Incomplete;/  struct A {/    virtual A* foo(Incomplete p) = 0;/  };/  struct B : virtual A {/    void foo(Incomplete p) override;/  };/  struct C : B { int c; };//This TU is valid, but lacks a definition of 'Incomplete', which makes it/hard to build a thunk for the final overrider, B::foo.//Before this change, Clang gives up attempting to emit the thunk, because/it assumes that if the parameter types are incomplete, it must be/emitting the thunk for optimization purposes. This is untrue for the MS/ABI, where the implementation of B::foo has no idea what thunks C's/vftable may require. Clang needs to emit the thunk without necessarily/having access to the complete prototype of foo.//This change makes Clang emit a musttail variadic call when it needs such/a thunk. I call these ""unprototyped"" thunks, because they only prototype/the ""this"" parameter, which must always come first in the MS C++ ABI.//These thunks work, but they create ugly LLVM IR. If the call to the/thunk is devirtualized, it will be a call to a bitcast of a function/pointer. Today, LLVM cannot inline through such a call, but I want to/address that soon, because we also use this pattern for virtual member/pointer thunks.//This change also implements an old FIXME in the code about reusing the/thunk's computed CGFunctionInfo as much as possible. Now we don't end up/computing the thunk's mangled name and arranging it's prototype up to/around three times.//Fixes PR25641//Reviewers: rjmccall, rsmith, hans//Subscribers: Prazek, cfe-commits//Differential Revision: https://reviews.llvm.org/D45112//llvm-svn: 329009",https://github.com/microsoft/checkedc-clang/commit/399d96e39c64f1fd3a00b78886a02abe58cdb36f,60645050,microsoft/checkedc-clang,False,False
5e01000d46291a02b4ab83cde088c7c7dc6f7aa2,"Start TFLite legalizer pass//Start of TFLite legalizer pass. Currently focussed on macro expanding ops, limited to what is registered directly in a separate pass (this should instead be a general pass), no querying of what gets produced, the matching is string based instead of using the ops proper (the matching TF ops should be defined) etc. This is a step to enable prototyping. In addition to the above shortcomings, the legalizer is very verbose in this form and should instead be driven by autogenerated patterns (same is true for the op builders too). But this starts from the explicit form and extracting out commonality in follow up.//Add definition for tfl.relu for basic selection of fused relu add.//PiperOrigin-RevId: 220287087",https://github.com/microsoft/checkedc-clang/commit/5e01000d46291a02b4ab83cde088c7c7dc6f7aa2,60645050,microsoft/checkedc-clang,False,False
518c2b7874153eeaa4779abde356985473b0debd,"Restrictions on redeclarations of no prototype functions. (#76)//Calls to no-prototype functions are not type checked according to the C specification (Section 6.5.2.2 of the C11 specification).  The lack of type checking allows the checking of bounds declarations to be bypassed.   For the Checked C extension, this is addressed by not allowing redeclarations of no-prototype functions to have prototypes that use checked types, as well as not allowing checked values to be passed to no-prototype functions.  Section 5.5 of the Checked C extension specification describes the restrictions.  ////This change implements the Checked C restrictions on redeclarations of no-prototype functions.  It is  part of work on issue #30.    The restrictions are implemented by changing the implementation of C type compatibility in clang.   We make no-prototype function types incompatible with function types that take arguments or return values that have checked types, contain values with checked types embedded within them, or are recursively pointers to function types that take or return check types.  We also change the construction of function types from function declarators to enforce the Checked C rule that a no-prototype function cannot have a checked return type.////When two declarations of a function are incompatible, we try to diagnose whether a failure is due to a Checked C type compatibility rule and print descriptive error messages.   We do this only when the failure  is because of the presence or absence of a prototype of a declaration.  We do not try to diagnose type compatibility problems involving parameters with function pointer types,  In that case, programmers will get a generic ""types are not compatible"" message.////There is a subtle complication when checking redeclarations in the presence of incomplete structure or union types.  In the Checked C rules, a function type with an incomplete type is compatible with a no-prototype function (because the incomplete type is unknown).  For a series of declarations of a function, clang merges the types so that the latest declaration has the merged type.  This means that a function could start as a no-prototype function, be given a prototype with an incomplete type, the incomplete type could be completed to be  checked type, and then the function could be declared again://```//int f();      // decl 1//struct S;//int f(S v);   // decl 2//// complete the type//struct S {//  ptr<int> p;//}//...//int f(S v) {  // decl 3 (possibly a definition)//  ...//}//```//clang looks at only the type of the prior declaration when merging declaration types.  For Checked C, this misses the fact that `f` was declared originally  as a no-prototype function at `decl 1`.   The prototype was allowed only because it involved an incomplete type at `decl 2`.  If we had the complete type at `decl 2`, the prototype would not have been allowed.  Instead of looking at just the prior declaration, we look back at all prior declarations of a function to make sure they are compatible with the current declaration of the function.////Note that we still need to prevent `decl 2` from being used after `S` is complete.  The current change only addresses redeclarations of `f`, not uses of `f`.   That is  future work tracked by issue #75. ////In the implementation of type compatibility, we miss the case of no-prototype function pointers being incompatible with prototype function pointers that take integer arguments with bounds.  This depends on issue #20 (adding bounds to function types).  We will address this case as part of issue #20.////Testing://- This change uncovered places in existing tests in the Checked C repo where we were using no prototype functions.  Update the tests to properly declare the functions as having no arguments (using the `f(void)` pattern).//- Add a new tests on to Checked C repo in typechecking\no_prototype_functions.c.//- Add some clang-specific tests under tests\CheckedC\typechecking.c.//- Passes the updated and new Checked C tests.//- Passes the existing clang regression tests.",https://github.com/microsoft/checkedc-clang/commit/518c2b7874153eeaa4779abde356985473b0debd,60645050,microsoft/checkedc-clang,False,False
eadc8a81ef3df4c986bd9b0f6676e0e49646fa0f,"[MS] Emit vftable thunks for functions with incomplete prototypes//Summary:/The following class hierarchy requires that we be able to emit a/this-adjusting thunk for B::foo in C's vftable://  struct Incomplete;/  struct A {/    virtual A* foo(Incomplete p) = 0;/  };/  struct B : virtual A {/    void foo(Incomplete p) override;/  };/  struct C : B { int c; };//This TU is valid, but lacks a definition of 'Incomplete', which makes it/hard to build a thunk for the final overrider, B::foo.//Before this change, Clang gives up attempting to emit the thunk, because/it assumes that if the parameter types are incomplete, it must be/emitting the thunk for optimization purposes. This is untrue for the MS/ABI, where the implementation of B::foo has no idea what thunks C's/vftable may require. Clang needs to emit the thunk without necessarily/having access to the complete prototype of foo.//This change makes Clang emit a musttail variadic call when it needs such/a thunk. I call these ""unprototyped"" thunks, because they only prototype/the ""this"" parameter, which must always come first in the MS C++ ABI.//These thunks work, but they create ugly LLVM IR. If the call to the/thunk is devirtualized, it will be a call to a bitcast of a function/pointer. Today, LLVM cannot inline through such a call, but I want to/address that soon, because we also use this pattern for virtual member/pointer thunks.//This change also implements an old FIXME in the code about reusing the/thunk's computed CGFunctionInfo as much as possible. Now we don't end up/computing the thunk's mangled name and arranging it's prototype up to/around three times.//Fixes PR25641//Reviewers: rjmccall, rsmith, hans//Subscribers: Prazek, cfe-commits//Differential Revision: https://reviews.llvm.org/D45112//git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@329009 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/clang/commit/eadc8a81ef3df4c986bd9b0f6676e0e49646fa0f,29706297,microsoft/clang,False,False
68a4b416482ea92fe9aa4f1adf86c6e0574a4186,"[PPC64LE] More vector swap optimization TLC//This makes one substantive change and a few stylistic changes to the/VSX swap optimization pass.//The substantive change is to permit LXSDX and LXSSPX instructions to/participate in swap optimization computations.  The previous change to/insert a swap following a SUBREG_TO_REG widening operation makes this/almost trivial.//I experimented with also permitting STXSDX and STXSSPX instructions./This can be done using similar techniques:  we could insert a swap/prior to a narrowing COPY operation, and then permit these stores to/participate.  I prototyped this, but discovered that the pattern of a/narrowing COPY followed by an STXSDX does not occur in any of our/test-suite code.  So instead, I added commentary indicating that this/could be done.//Other TLC:/ - I changed SH_COPYSCALAR to SH_COPYWIDEN to more clearly indicate/ the direction of the copy./ - I factored the insertion of swap instructions into a separate/ function.//Finally, I added a new test case to check that the scalar-to-vector/loads are working properly with swap optimization.///git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@242838 91177308-0d34-0410-b5e6-96231b3b80d8",https://github.com/microsoft/llvm/commit/68a4b416482ea92fe9aa4f1adf86c6e0574a4186,29704274,microsoft/llvm,False,False
2be8054b49c42a6bd7d1e94f2b9ca24d92ae7311,"[PPC64LE] More vector swap optimization TLC//This makes one substantive change and a few stylistic changes to the/VSX swap optimization pass.//The substantive change is to permit LXSDX and LXSSPX instructions to/participate in swap optimization computations.  The previous change to/insert a swap following a SUBREG_TO_REG widening operation makes this/almost trivial.//I experimented with also permitting STXSDX and STXSSPX instructions./This can be done using similar techniques:  we could insert a swap/prior to a narrowing COPY operation, and then permit these stores to/participate.  I prototyped this, but discovered that the pattern of a/narrowing COPY followed by an STXSDX does not occur in any of our/test-suite code.  So instead, I added commentary indicating that this/could be done.//Other TLC:/ - I changed SH_COPYSCALAR to SH_COPYWIDEN to more clearly indicate/ the direction of the copy./ - I factored the insertion of swap instructions into a separate/ function.//Finally, I added a new test case to check that the scalar-to-vector/loads are working properly with swap optimization.//llvm-svn: 242838",https://github.com/microsoft/checkedc-clang/commit/2be8054b49c42a6bd7d1e94f2b9ca24d92ae7311,60645050,microsoft/checkedc-clang,False,False
