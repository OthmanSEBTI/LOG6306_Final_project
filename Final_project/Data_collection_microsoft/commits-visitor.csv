sha,message,html_url,repository_id,repository_full_name,repository_private,repository_fork
38d9dafaa3c361331ac03996f8e942055df4842e,"Fuse passes//Summary:/Rather than creating a visitor from each of our composable pass definitions, this diffs combines the passes and create a single visitor.//Care is taken to ensure that the composed visitor is equivalent to the sequence of visitors; this means:/- avoiding pattern matching more than one layer deep in top-down passes (since the AST elements at the next level will not yet have been elaborated)/- breaking some passes into top-down & bottom-up passes where we build the context in the top-down pass but apply the transformation in the bottom-up pass (this lets us do pattern matching more than one layer deep)//The diff also puts the passes into a sensible order:/- canonicalization pass which transform the lowered AST into the form we expect for typing/- passes to replace invalid hints and expressions with markers/- passes which are soley typechecking concerns i.e. elaboration & validation driven by typechecker options//Reviewed By: CatherineGasnier//Differential Revision: D41581813//fbshipit-source-id: 2a21a5e2c0cbe78822ce1ac01b50c25f241b31a2",https://github.com/facebook/hhvm/commit/38d9dafaa3c361331ac03996f8e942055df4842e,455600,facebook/hhvm,False,False
ccc42667e7a24cfca19f1a12733ec8d893cdee5d,Add visitors for children of AST nodes//Summary:/Create a simple visitor pattern in the AST by adding two traits:/* `Visitor` allows callers to provide a callback for each AST node/* `Visitable` allows the visitor pattern to call the same function/  on each field and have it do the right thing.//The visitor is also responsible for visiting its children or terminating/as required (in similar fashion to the Hermes `RecursiveVisitor`).//Reviewed By: tmikov//Differential Revision: D29623394//fbshipit-source-id: fb4dd0e8481c83861f98da0d0bdacc499f2e3a05,https://github.com/facebook/hermes/commit/ccc42667e7a24cfca19f1a12733ec8d893cdee5d,154201259,facebook/hermes,False,False
af1eae9ea313b016f111a25b5252b70aea99aedd,New Props parsing infrastructure for perf improvements: visitor pattern vs random-map-access pattern (BaseTextProps and derived props)//Summary:/See commentary at top of stack.//Changelog: [Added][Fabric] New API for efficient props construction//Reviewed By: javache//Differential Revision: D37051020//fbshipit-source-id: 643e433c0d0590cfcd17bc7a43d105bed6ff12ef,https://github.com/facebook/react-native/commit/af1eae9ea313b016f111a25b5252b70aea99aedd,29028775,facebook/react-native,False,False
2ab585ac26797527da728f52528b9850c09a57b1,New Props parsing infrastructure for perf improvements: visitor pattern vs random-map-access pattern (ScrollViewProps)//Summary:/See commentary at top of stack.//Changelog: [Added][Fabric] New API for efficient props construction//Reviewed By: javache//Differential Revision: D37050961//fbshipit-source-id: 170a09c08d7406b6aac51d7e78cf295a72fdcf91,https://github.com/facebook/react-native/commit/2ab585ac26797527da728f52528b9850c09a57b1,29028775,facebook/react-native,False,False
9f8c45deb7bc0d646fb6884c2d0a978246253cad,New Props parsing infrastructure for perf improvements: visitor pattern vs random-map-access pattern (YogaLayoutableShadowNode / YGStyle)//Summary:/See commentary at top of stack.//Changelog: [Added][Fabric] New API for efficient props construction//Reviewed By: javache//Differential Revision: D37050376//fbshipit-source-id: 2bea35a6d604704cf430bd3b2914988227d1abf8,https://github.com/facebook/react-native/commit/9f8c45deb7bc0d646fb6884c2d0a978246253cad,29028775,facebook/react-native,False,False
7492abc3944e39b1952081132d5e4b35616e3e3e,"Switch coverage_data to collect in static functions//Summary:/I want to add a collector function for `AnnotationCollector`, but/I realized the pattern of using a `collect` method on the classes does/not really allow this. The reason is that we're using inheritance to/inherit behavior and attributes in the `AnnotationCountCollector`/used by `statistics.py`, but overriding `collect` with a different/output type isn't valid in terms of static typing.//(The collector I was trying to add when I realized this problem is/provided by the `collect_function_annotations` function defined/in this commit - that code cannot be implemented as a `collect`/method without introducing type errors).//This suggests that, given our desire to inherit behavior but not/the output data interface, the collect methods don't really belong/on the classes at all; instead I'm making them static module-level/functions.//I think the callsites are easier to read than intantiating a class/and calling collect anyway; the fact that there's a visitor involved/is really an implementation detail rather than something downstream/code really needs to be exposed to.//I'm not updating the `statistics.py` code, which is in maintenance/mode anyway so having collect as a method should be fine there for/the short remaining lifetime of the code.//Reviewed By: grievejia//Differential Revision: D44587343//fbshipit-source-id: efb454c1e39abb2a8f43b22d2fef75be63f4bd7f",https://github.com/facebook/pyre-check/commit/7492abc3944e39b1952081132d5e4b35616e3e3e,110274488,facebook/pyre-check,False,False
6e92d75c3fea93e5d26fe7911e2d3a5e1d6db020,"es6 scope builder: pattern refactoring//Summary:/Refactored pattern visitors to be more principled: there are binding patterns/and assignment patterns, and we carefully thread those through the visitor.//This helps get rid of lexical_* visitor methods, among other things.//Reviewed By: mroch//Differential Revision: D5333196//fbshipit-source-id: 1ac8a9ed186d4c677fa5e3770f3d73cf8ae76373",https://github.com/facebook/flow/commit/6e92d75c3fea93e5d26fe7911e2d3a5e1d6db020,25880891,facebook/flow,False,False
ec35cdb6b45ca1627d71bac9b08d3f47fda9e861,"Move code out of juno_ast lib.rs//Summary:/`lib.rs` was getting to have too much code in it and the public API/was getting muddled by the excess of real code we had to read through.//Clean things up by making new files:/* `node_child.rs` contains the actual `NodeChild` trait and all the/  basic node children: lists, nodes, strings, etc./* `node_enums.rs` contains the trivial enums that we use for things like/  operator kinds, import/export kinds, etc./* `visitor.rs` contains the `Visitor` patterns and their helpers.//`lib.rs` now more clearly designates the public API for the `juno_ast`/crate and we should continue to ensure that it contains no code.//All the movement is invisible to any users of the crate, as the public/API is completely unchanged.//Reviewed By: tmikov//Differential Revision: D37698636//fbshipit-source-id: 1f6f0800169ff3a466d607286b3b8baa427ee432",https://github.com/facebook/hermes/commit/ec35cdb6b45ca1627d71bac9b08d3f47fda9e861,154201259,facebook/hermes,False,False
211e027869b56ac9863783fb7e2c6485b26890d9,"Reduce stack frame size of Visitor::recurse() impls//Summary:/Most of the stack bloat in hackc closure_convert comes from various Visitor/impls for enum node types, especially Expr_. These are code generated to look like://  fn recurse(...) -> Result<(), E> {/    match self {/      Variant1(a) => {/        a.0.accept(v, c)?;/        .../        a.n.accept(v, c)?;/        Ok(())/      }/      .../    }/  }//There are several contributors to stack bloat in mode/dbg builds:/ 1. in dbg builds, each arm contributes to the frame size, but only 1 is active at runtime/ 2. each occurance of `?` and `Ok(())` contributes O(sizeof(E)) to the frame size. In closure_convert,/E = `emitter::instruction_sequence::Error`, which is somewhat bloaty (approximately 8x64 bit words)./We see a much larger stack frame compared to elaborate_namespace_visitor, where E =`()`./ 3. The final Ok(()) of each arm is unnecessary; we can tail-call the final accept() instead.//This diff addresses (1) and (3) by changing the oxidized code gen to use helper functions/when there are more than two accept()s in an enum match, and tail-call the last accept()/when there is at least one (in pattern matches and struct nodes).//Differential Revision: D34851838//fbshipit-source-id: ad64a865857a74d9d5f62872a0a26fb8e249af60",https://github.com/facebook/hhvm/commit/211e027869b56ac9863783fb7e2c6485b26890d9,455600,facebook/hhvm,False,False
67175ce898975601acd8e8b73c1bb922cf4cb445,"Use linked list for node list storage//Summary:/Remove the `Vec`s from the AST by using a simple linked list for/`NodeList` instead. At the moment, there's no reason for a doubly linked/list due to the immutability of the AST, so it's only singly linked but/can be changed in the future.//A non-empty `NodeList` is created via `from_iter`, allowing flexibility/for the caller in creation. `NodeList::from_iter` is the only function/that calls `Context::append_list_element`, which is the only means/of modifying a `NodeList`. Thus, `NodeList`s are immutable after/creation, from the perspective of the user.//Storage for the links is separate from the main node storage, to avoid/extra overhead as most nodes won't be elements of a `NodeList`.//Introduce a `mark_lists` function on `Node` in order to mark the/actual list elements. This is necessary because the existing visitor/pattern only visits `Node`s, so we need a way to visit `NodeListElement`/to set the mark bits. `mark_lists` is non-recursive, so it's just a/helper function to mark all the elements.//NOTE: Not all locations are converted to use the linked lists yet:/in particular, the mutable visitor uses `Vec`s to communicate expansion./Still have to figure out a good way to handle that.//Reviewed By: tmikov//Differential Revision: D34585094//fbshipit-source-id: a7492934953a415c40dd7eea9b150ab462cd3ad6",https://github.com/facebook/hermes/commit/67175ce898975601acd8e8b73c1bb922cf4cb445,154201259,facebook/hermes,False,False
a5eda15ad078a9e7f282198a35524209b000e443,"add Flow_ast_mapper type_identifier visitor//Summary:/adds a visitor to `Flow_ast_mapper` to intercept all type identifiers (like `T` in `type T = ...` or `(x: T)`) so that you can write a mapper that finds all types more easily.//the only real difference here is that `import type { T }` and `import { type T }` now send `T` through `type_identifier` -> `identifier`, instead of `pattern_identifier ~kind:Let` -> `identifier`. this seems like a fix, not a bug, because imported types are not actually let bindings. afaict, nothing is using this anyway.//Reviewed By: panagosg7//Differential Revision: D26439015//fbshipit-source-id: ff5b8f16d646b9cbd98cb4729c2c80ce52c75abd",https://github.com/facebook/flow/commit/a5eda15ad078a9e7f282198a35524209b000e443,25880891,facebook/flow,False,False
3450f9eca32525621e72a14742125874354d6cad,"Add Width parameter to Vinstr use/def visitors//Summary:/I got tired of writing boilerplate Visitor classes, so now we have this/which should tide us over until we get lambdas with auto parameters in/C++14.//Also refactor and extend the MaybeConst parameter pattern while we're/here.//Reviewed By: swtaarrs//Differential Revision: D3730204//fbshipit-source-id: 9a4e1b0331d49e892e584caca063769aaae0d78a",https://github.com/facebook/hhvm/commit/3450f9eca32525621e72a14742125874354d6cad,455600,facebook/hhvm,False,False
9d307f3b318662b9854fe753f9a1d3654551563b,"Implement a Stateful NAST Check//Summary:/Currently, the nast_check visitor is a bit unwieldy to use for stateful/context based error checks. Each method of a nast check visitor is context free but there are many error checks that require some context/state to correctly report errors. Currently, many of these checks do one of the following to gain context/stateful capabilities.//1. Add context/state to the global nast check env/2. Retain context/state locally in the visitor via a stateful reference/3. Implement another stateful visitor and call into that//There are a couple of problems with each:/1. The code to do this is a non obvious pattern. It also pollutes the global environment with state that is only needed in one particular visitor/2. Updating a reference statefully is difficult to reason about within the visitor framework/3. This breaks out assumption that we will only make one pass over the ast for all checks, instead of one per check.//This diff creates a framework for a stateful nast check visitor where each visitor is able to retain its own state when iterating over the AST.//Reviewed By: Wilfred//Differential Revision: D21292538//fbshipit-source-id: 9fe6929435fed28a177c7cc2fe82c896a90c97a9",https://github.com/facebook/hhvm/commit/9d307f3b318662b9854fe753f9a1d3654551563b,455600,facebook/hhvm,False,False
5ad95d3a57de5d12b809c96bb97378308c6a39b6,"Fix shorthands on LHS//Summary:/This fix will hopefully unblock prettier by ensuring that object property shorthands on the LHS are not converted to being non-shorthand unless necessary. This is the same logic used in D32258284 (https://github.com/facebook/flow/commit/099f88b4e9937c39e4f6f54c2fb1d3584ef8d3c0), just now applied to pattern objects.//While the issue here is clear, I'm mystified why this just started being a problem in a recent version, as reported in #8776, since the change we believed was the culprit there (D31453075 (https://github.com/facebook/flow/commit/806cc9c6c3023cf4c1a82bb4114aa5239fd3285e)) doesn't affect LHS properties at all, and the code for always making a pattern object shorthand false has been around for a while. Maybe some new visitor pass started happening? Notably, the issue only arose when --include-comments is false.//Closes #8793//Changelog: [internal]//Reviewed By: mroch//Differential Revision: D32786899//fbshipit-source-id: a57f2d55a14362ef596692aaef356113f938bd2c",https://github.com/facebook/flow/commit/5ad95d3a57de5d12b809c96bb97378308c6a39b6,25880891,facebook/flow,False,False
f29298d91cba86c5181a449719a03712da539fec,"A code review comment for Bug#52289.//Encapsulate the deadlock detection functionality into /a visitor class, and separate it from the wait-for graph/traversal code.//Use ""Internal iterator"" and ""Visitor"" patterns to /achieve the desired separation of responsibilities.//Add comments.",https://github.com/facebook/mysql-5.6/commit/f29298d91cba86c5181a449719a03712da539fec,9454675,facebook/mysql-5.6,False,False
58d53f7a58b13a5b1a689736b9d9858aad92e188,"WL#5371 PERFORMANCE_SCHEMA Instrumenting Table Locks/WL#5379 PERFORMANCE SCHEMA TABLE / INDEX IO SUMMARY/WL#5420 PERFORMANCE SCHEMA TABLE LOCK WAIT SUMMARY//Code cleanup,/implemented a visitor pattern to reduce code duplication.",https://github.com/facebook/mysql-5.6/commit/58d53f7a58b13a5b1a689736b9d9858aad92e188,9454675,facebook/mysql-5.6,False,False
1f7dd3c9a475c06fa689d8fcc5a448f94e77bf7b,Fix count of uses for reused inout variable//Summary: Fix pattern matching logic in `handle_arg` and its visitor to correctly count the number of uses for a reused inout variable in an argument list//Reviewed By: shiqicao//Differential Revision: D21732544//fbshipit-source-id: 2a5677a971348def0f5bfc40b1e9eb50c152f901,https://github.com/facebook/hhvm/commit/1f7dd3c9a475c06fa689d8fcc5a448f94e77bf7b,455600,facebook/hhvm,False,False
43be6443483deabf02f166cd1cc2160287438ad1,"[enums] Fix enum declaration visitor//Summary:/The `flow_ast_mapper` method for visiting enum declarations originally visited the name of the enum using the `identifier` method. Typically, `identifier` is used for visiting *reads* of expressions, but the identifier in an enum declaration is a *write*, which should be visited using `pattern_identifier` (see corresponding pattern in ex. class and function declarations). `pattern_identifier` takes an optional `kind`, which represents what kind of variable is being declared (when this is a declaration and not just a write); in the case of enums I think this is `const`, since enums compile to `const` declarations (right?)//This change fixes the `ssa_builder` test case for enums without any other change needing to be made because the ssa builder now correctly understands the enum identifier as a write rather than a read.//Reviewed By: gkz//Differential Revision: D28204020//fbshipit-source-id: e9b596beaa465b70c1bbc2ca2cdd21bec0881ec3",https://github.com/facebook/flow/commit/43be6443483deabf02f166cd1cc2160287438ad1,25880891,facebook/flow,False,False
b9d189890941da2a93e892f53a0884de842baa30,"Refactor Label iteration//Summary:/A number of different bytecode instructions have one or more Labels to represent branch targets./The hackc emitter needs to visit all Labels for various reasons; the `Instruct ADT` has them scattered/around in different places making it verbose and error prone to visit them correctly.//This diff introduces an idiom we used in the hacknative IR for operands and branch targets/that is fast and encapsulated. We provide accessors that return slices, either `&[Label]` or/`&mut [Label]`, which only have to do the careful pattern match in one place./Now client code can work with slices (fast), and pattern matching is simplified.//Iterating over a slice is easy (a for loop or iterator chain). If the visitor is a lambda, it is only/called or instantiated in one place, which simplifies code. Transposing/SSwitch's `Vec<Pair(Str,Label)>` to { Vec<Str>, Vec<Label> }, avoids the need for a/transient Vec<Label> in label_rewriter.//Clarify naming a little bit: a Label operand to a conditional branch instruction is a *target*,/not to be confused with a `ILabel(Label)` instruction which marks the location conditional/branches jump to.//Reviewed By: aorenste//Differential Revision: D34112173//fbshipit-source-id: 8ae82e96a855659f083fbcbffcf1b152b9f46ea0",https://github.com/facebook/hhvm/commit/b9d189890941da2a93e892f53a0884de842baa30,455600,facebook/hhvm,False,False
8bd356fad28377eb73636238cb13fcc516fbeb5f,Basic field renaming in Redex//Summary:/Added basic field renaming. It renames only fields that should be renamed according to the `keep` and `allow_obfuscation` flags. Mirrors ProGuard implementation except with a much simpler visitor pattern for clearer correctness. Should respect inheritance.//Does not:/- modify the ProGuard mapping/- do a final verification pass looking for conflicts/- use descriptor information for more aggressive overloading/- respect ProGuard flags//Reviewed By: satnam6502//Differential Revision: D4009507//fbshipit-source-id: bea6e326045adf3f757df852650153a5954922c4,https://github.com/facebook/redex/commit/8bd356fad28377eb73636238cb13fcc516fbeb5f,54664770,facebook/redex,False,False
5685edf31b85d2a054de1304d762ce52b30056ed,"Move env setting from iter_with to iter//Summary:/Examining our usages of tast_check and the tast_visitor, I believe that we should be more disciplined about the way that we write tast checks.//Rather than set tast_env details in the `iter_with` class, I'd rather set the environmental items in the `iter` class - this has the effect of correctly having all classes inheriting from `iter` to also get the change. We need to duplicate this for the `iter_with_state`. This is also more consistent with the current pattern of env setting.//Reviewed By: losvald//Differential Revision: D19044954//fbshipit-source-id: e4aaa6dfcf92ea30a9f820556fdee210bfa0cc43",https://github.com/facebook/hhvm/commit/5685edf31b85d2a054de1304d762ce52b30056ed,455600,facebook/hhvm,False,False
47280de85e62f33f0b97bc1ed7c83bc6ca0dc7d4,"New Props parsing infrastructure for perf improvements: visitor pattern vs random-map-access pattern (ViewProps, minus YogaLayoutableShadowNode)//Summary:/Perf numbers for this stack are given in terms of before-stack and after-stack, but the changes are split up for ease of review, and also to show that this migration CAN happen per-component and is 100% opt-in. Most existing C++ components do not /need/ to change at all.//# Problem Statement//During certain renders (select critical scenarios in specific products), UIManagerBinding::createNode time takes over 50% of JS thread CPU time. This could be higher or lower depending on the specific product and interaction, but overall createNode takes a lot of CPU time. The question is: can we improve this? What is the minimal overhead needed?//The vast, vast majority of time is taken up by prop parsing (specifically, converting JS values across the JSI into concrete values on the C++ props structs). Other methods like appendChild, etc, do not take up a significant amount of time; so we conclude that createNode is special, and the JSI itself, or calling into C++, is not the problem. Props parsing is the perf problem.//Can we improve it? (Spoiler: yes)//# How does props parsing work today?//Today, props parsing works as follows://1. The ConcreteComponentDescriptor will construct a RawPropsParser (one per component /type/, per application: so one for View, one for Image, one for Text... etc)/2. Once per component type per application, ConcreteComponentDescriptor will call ""prepare"" on the RawPropsParser with an empty, default-constructed ConcreteProps struct. This ConcreteProps struct will cause RawProps.at(field) for every single field./3. Based on the RawProps::at calls in part 2, RawPropsParser constructs a Map from props string names (width, height, position, etc) to a position within a ""value index"" array./4. The above is what happens before any actual props are parsed; and the RawPropsParser is now ready to parse actual Props./5. When props are actually being parsed from a JSI dictionary, we now have two phases:/  1. The RawPropsParser `preparse`s the RawProps, by iterating over the JSI map and filling in two additional data structures: a linear list of RawValues, and a mapping from the ValueIndex array (`keyIndexToValueIndex_`; see step 3) to a value's position in the values list (`value_` in RawPropsParser/RawProps);/  2. The ConcretePropT constructor is called, which is the same as in step 2/3, which calls `fieldValue = rawProps.at(""fieldName"")` repeatedly./  3. For each `at` call, the RawProps will look up a prop name in the Map constructed in step 3, and either return an empty value, or map the key name to the `keyIndexToValueIndex_` array, which maps to a value in `values_`, which is then returned and further parsed.//So, a few things that become clear with the current architecture://1. Complexity is a property of the number of /possible/ props that /can/ be parsed, not what is actually used in product code. This violates the ""only pay for what you use"" principal. If you have `<View opacity={0.5} />`, the ViewProps constructor will request ~170 properties, not 1!/2. There's a lot of pre-parsing which isn't free/3. The levels of indirection aren't free, and make cache misses more likely and pipelining is more challenging/4. The levels of indirection also require more memory - minor, but not free//# How can we improve it?//The goal is to improve props parsing with minimal or zero impact on backwards-compability. We should be able to migrate over components when it's clear there's a performance issue, without requiring everything gets migrated over at once. This both (1) helps us prove out the new architecture, (2) derisks the project, (3) gives us time, internally and externally, to perfect the APIs and gradually migrate everything over before deleting the old infrastructure code entirely.//Thus, the goal is to do something that introduces a zero-cost abstraction. This isn't entirely possible in practice, and in fact this method slightly regresses components that do not use the new architecture /at all/, while dramatically improving migrated components and causing the impact of the /old/ architecture to be minimal.//# Solution//1. We still keep the existing system in place entirely./2. After Props are constructed (see ConcreteComponentDescriptor changes) we iterate over all the /values/ set from JS, and call PropsT::setProp. Incidentally, this allows us to easily reuse the same prop for multiple values for ""free"", which was expensive in the old system./3. It's worth noting that this makes a Props struct ""less immutable"" than it was before, and essentially now we have a ""builder pattern"" for Props. (If we really wanted to, we could still require a single constructor for Props, and then actually use an intermediate PropsBuilder to accumulate values - but I don't think this overhead would be worth for the conceptual ""immutability"" win, and instead a ""Construct/Set/Seal"" model works fine, and we still have all the same guarantees of immutability after the parsing phase)//# Implementation Details/# How to properly construct a single Prop value//Minor detail: parsing a single prop is a 3-step process. We imagine two scenarios: (1) Creating a new ShadowNode/Props A from nothing/void, so the previous Props value is just the default constructor. (2) Cloning a ShadowNode A->B and therefore Props A must be copied to Props B before parsing.//We will denote this as a clone from A->B, where A may or may not be a previous node or a default-constructed Props node; and imagine in particular that we're setting the ""opacity"" value for PropsB.//We must first (1) copy a value over from the previous version of the Props struct, so B.opacity = A.opacity; (2) Determine if opacity has been set from JS. If so, and there is a value, B.opacity = parse(JSValue). (3) If JS has passed in a value for the prop, BUT the value is `null`, it means that JS is resetting or deleting the prop, so we must set it BACK to the default. In this case we set PropsB.opacity = DefaultConstructedProps.opacity.//We must take care in general to ensure that the correct behavior is achieved here, which should help to explain some of the code below.//## String comparisons vs hash comparisons//In the previous system, a RawPropsKey is three `const char*` strings, concatenated together repeatedly /at runtime/. In practice, the ONLY reason we have the prefix, name, suffix Key structure is for the templated prop parsing in ViewProps and YogaStyableProps - that's it. It's not used anywhere else. Further, the key {""margin"", ""Left"", ""Width""} is identical to the key {""marginLeftWidth"", null, null} and we don't do anything fancy with matching prefixes before comparing the whole string, or similar. Before comparison, keys are concatenated into a single string and then we use `strcmp`. The performance of this isn't terrible, but it's nonzero overhead.//I think we can do better and it's sufficient to compare hashed string values; even better, we can construct most of these /at compile time/ using constexpr, and using `switch` statements guarantee no hash collisions within a single Props struct (it's possible there's a collision between Props.cpp and ViewProps.cpp, for example, since they're different switch statements). We may eventually want to be more robust against has collisions; I personally don't find the risk to be too great, hash collisions with these keys are exceedingly unlikely (or maybe I just like to live dangerously). Thus, at runtime, each setProp requires computing a single hash for the value coming from JS, and then int comparisons with a bunch of pre-compiled values.//If we want to be really paranoid, we could be robust to hash collisions by doing `switch COMPILED_HASH(""opacity""): if (strcmp(strFromJs, ""opacity"") == 0)`. I'm happy to do this if there's enough concern.//## Macros//Yuck! I'm using lots of C preprocessor macros. In general I found this way, way easier in reducing code and (essentially) doing codegen for me vs templated code for the switch cases and hashing prop names at compile-time. Maybe there's a better way.//Changelog: [Added][Fabric] New API for efficient props construction//Reviewed By: javache//Differential Revision: D37050215//fbshipit-source-id: d2dcd351a93b9715cfeb5197eb0d6f9194ec6eb9",https://github.com/facebook/react-native/commit/47280de85e62f33f0b97bc1ed7c83bc6ca0dc7d4,29028775,facebook/react-native,False,False
469a9d7aab68472bba04386874d690872d1949a1,"Fix unexpected typedef naming error//Summary:/```/type IntTypedef = int;//function test(): void {/  (int)((IntTypedef $amount) ==> 0);/}/```//was previously throwing an unexpected typedef error at the IntTypedef position in the lambda parameter.//Although the `Cast` node does not allow the hint to be a typedef, it should allow the expression that is being casted to include typedefs.//Rather than setting the environment correctly in naming, we rely on the invariant that the parser only allows for certain hints to be cast to. I believe they are like `string | int | bool`//I think that this mistake is another argument against the visitor pattern we have been employing for our checks :///Reviewed By: arxanas//Differential Revision: D21782094//fbshipit-source-id: 1583f87f80486dffb1906b0cb08b1f524ca902ba",https://github.com/facebook/hhvm/commit/469a9d7aab68472bba04386874d690872d1949a1,455600,facebook/hhvm,False,False
c0f685832faeca511523924f75d2e6b93ed78a55,"Move inout check to nast_check//Summary:/Moves check of inout expression to nast_check./The nast_check visitor appears to traverse a different tree than nastCheck./This is evidenced by $this and $$ appearing in the tree traversed by nast_check, and not appearing in the tree traversed by nastCheck.//A pattern was added to test for these cases. The tests for these cases are:/- $this : test/typecheck/inout/bad_inout_use_this.php/- $$     : test/typecheck/inout/bad_inout_use_pipe_var.php//Finally, in test case bad_inout_use_arg11.php, the errors thrown were reordered. When testing with a higher number of maximum errors, the previous expected error was thrown after.//Reviewed By: kmeht//Differential Revision: D15864177//fbshipit-source-id: 993beabb96e6dcf06f801cbdddcf76508ff2cc0c",https://github.com/facebook/hhvm/commit/c0f685832faeca511523924f75d2e6b93ed78a55,455600,facebook/hhvm,False,False
a724a3b578dce77d427bef313102a4d0e978d9b4,"[RFC] Codemod invariant -> throw new Error (#22435)//* Hoist error codes import to module scope////When this code was written, the error codes map (`codes.json`) was//created on-the-fly, so we had to lazily require from inside the visitor.////Because `codes.json` is now checked into source, we can import it a//single time in module scope.////* Minify error constructors in production////We use a script to minify our error messages in production. Each message//is assigned an error code, defined in `scripts/error-codes/codes.json`.//Then our build script replaces the messages with a link to our//error decoder page, e.g. https://reactjs.org/docs/error-decoder.html/?invariant=92////This enables us to write helpful error messages without increasing the//bundle size.////Right now, the script only works for `invariant` calls. It does not work//if you throw an Error object. This is an old Facebookism that we don't//really need, other than the fact that our error minification script//relies on it.////So, I've updated the script to minify error constructors, too:////Input://  Error(`A ${adj} message that contains ${noun}`);//Output://  Error(formatProdErrorMessage(ERR_CODE, adj, noun));////It only works for constructors that are literally named Error, though we//could add support for other names, too.////As a next step, I will add a lint rule to enforce that errors written//this way must have a corresponding error code.////* Minify ""no fallback UI specified"" error in prod////This error message wasn't being minified because it doesn't use//invariant. The reason it didn't use invariant is because this particular//error is created without begin thrown — it doesn't need to be thrown//because it's located inside the error handling part of the runtime.////Now that the error minification script supports Error constructors, we//can minify it by assigning it a production error code in//`scripts/error-codes/codes.json`.////To support the use of Error constructors more generally, I will add a//lint rule that enforces each message has a corresponding error code.////* Lint rule to detect unminified errors////Adds a lint rule that detects when an Error constructor is used without//a corresponding production error code.////We already have this for `invariant`, but not for regular errors, i.e.//`throw new Error(msg)`. There's also nothing that enforces the use of//`invariant` besides convention.////There are some packages where we don't care to minify errors. These are//packages that run in environments where bundle size is not a concern,//like react-pg. I added an override in the ESLint config to ignore these.////* Temporarily add invariant codemod script////I'm adding this codemod to the repo temporarily, but I'll revert it//in the same PR. That way we don't have to check it in but it's still//accessible (via the PR) if we need it later.////* [Automated] Codemod invariant -> Error////This commit contains only automated changes:////npx jscodeshift -t scripts/codemod-invariant.js packages --ignore-pattern=""node_modules/**/*""//yarn linc --fix//yarn prettier////I will do any manual touch ups in separate commits so they're easier//to review.////* Remove temporary codemod script////This reverts the codemod script and ESLint config I added temporarily//in order to perform the invariant codemod.////* Manual touch ups////A few manual changes I made after the codemod ran.////* Enable error code transform per package////Currently we're not consistent about which packages should have their//errors minified in production and which ones should.////This adds a field to the bundle configuration to control whether to//apply the transform. We should decide what the criteria is going//forward. I think it's probably a good idea to minify any package that//gets sent over the network. So yes to modules that run in the browser,//and no to modules that run on the server and during development only.",https://github.com/facebook/react/commit/a724a3b578dce77d427bef313102a4d0e978d9b4,10270250,facebook/react,False,False
