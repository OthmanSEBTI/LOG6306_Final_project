sha,message,html_url,repository_id,repository_full_name,repository_private,repository_fork
c1e9a8ee561d6191fe15633af31948ade80d726a,"ObserverContainer//Summary:/Introduces `folly::ObserverContainer`, a library that makes it easy to add support for observers to an object.//An observer is an object that is notified about changes to / events affecting the observed object through an interface defined by said object. `folly::ObserverContainer` generalizes a design pattern that has been applied to add support for observers to a few different classes at Meta, including `folly::AsyncSocket` and `wangle::Acceptor` and in parallel addresses some limitations of those designs.//In addition to generalizing this design pattern, `folly::ObserverContainer` will reduce the amount of boilerplate code required to write an observer and to add support for observers to an existing object.//**Benefits of `folly::ObserverContainer`**://A simple way to add support for an observer to an object is to define an interface, and then add a setter that sets a pointer to an object that has implemented that interface.//`folly::ObserverContainer` has a number of advantages over the simple pattern://- It enables an object to have multiple observers. More generally, a single observer can observe multiple objects, and an object can have multiple observers (e.g., supports N:N relationships between observers and observable objects)./- It provides an observer implementation (`ManagedObserver`) that ensures that the observer is detached from the observer list on its destruction, thus ensuring that there are never any dangling observers./- It (safely) supports observers being added or removed during processing of an event./- It enables observers to subscribe to given events, which in turn enables the object being observed to avoid the collection/generation of more expensive events if no observer is interested in them./- It handles corner cases, such as `move` construction, during which observers should be moved from one instance to another.//**How does `folly::ObserverContainer` compare to X?**://A common question about this design pattern is ""*Why do we need all of this? Couldn't we get the same benefits from an intrusive list or a list of `shared_ptr`?*"". `folly::ObserverContainer` provides a few advantages over those solutions:/- If the observer list is designed as a list of `shared_ptr`, it prevents objects that are not allocated as `shared_ptr` from acting as observers. Likewise, it prevents objects that manage their own lifecycle (e.g., that destroy themselves) from being observers. While `weak_ptr` can get around the latter issue, it does not resolve the former./- If the observer list is designed as an intrusive list, it makes it harder for a single observer to observe multiple objects. That's because for each object observed the observer will need to have a intrusive list hook; storage of those hooks becomes an interesting challenge./- `folly::ObserverContainer`  provides scaffolding that ensures correctness around observers being added or removed during processing of an event, enables observers to subscribe to events./- `folly::ObserverContainer` enables observers to know what objects they're currently attached to. A `shared_ptr` in comparison wouldn't provide this — an observer monitoring multiple objects won't know which objects it is attached to at any point in time without the additional signaling provided by `ObserverContainer`.//**How to use `folly::ObserverContainer`**://The following defines the steps that would be used to add support for observers to a given class and then instantiate an observer.//1. Define an interface that contains methods corresponding to the events that the observers should be able to receive. In parallel, define an enum containing each of these events./2. Change the class for the object being observed so that it has a member of type `folly::ObserverContainer`. Add calls to `invokeInterfaceMethod` at the points where observer events should be delivered./3. Single object observers can derive from `folly::ObserverContainer::ManagedObserver`. Instantiate an object of the derived class, attach it to a list, and begin getting events./4. If the observer is destroyed before the subject, the observer will remove itself from the list.//**Caveats and TODO**://`folly::ObserverContainer` has a few key limitations://- There is no thread safety (although it is possible to use policy to conditionally add such support). This means that all changes to the container must occur from a single thread./- `ManagedObserver` assumes that the observer is driven exclusively by the same thread as the thread that controls the object being observed. If that's not the case, `Observer` needs to be used instead.//The following will be added in subsequent diffs://- Support for move construction of observed objects, and support for move and destroy contexts./- A helper class similar to `ManagedObserver` that supports observing multiple objects at once (right now, doing this requires deriving from `Observer` directly)/- Documentation added to `ObserverContainer.h` that tells you how to use it — I'm delaying adding this until the entire library is built out since a few of the recommendations that I will make in the planned documentation cannot be supported until some of the subsequent diffs land.//Reviewed By: nspring//Differential Revision: D27062840//fbshipit-source-id: c2351286e93bc95aa7eabf222375713559669347",https://github.com/facebook/folly/commit/c1e9a8ee561d6191fe15633af31948ade80d726a,4524181,facebook/folly,False,False
d9ade0d1ed852bf64f17a3ed5846c9b41bbe84ba,"[tests] [9/n] Move memory leak test to Pulse//Summary: This test is about when an object gets released using a handler block. This is a pattern that infer can't handle. However, in the example, we don't report a leak because we pass observer to a skipped function.//Reviewed By: jvillard//Differential Revision: D32314226//fbshipit-source-id: fc4304e78",https://github.com/facebook/infer/commit/d9ade0d1ed852bf64f17a3ed5846c9b41bbe84ba,29857799,facebook/infer,False,False
0854371ab02ddbaf979c37e613e5a913dd477a66,"Functorize Implicit_instantiation module//Summary:/Instead of passing around functions directly and forcing every user of the Implicit_instantiation module to add code for their use case into the Implicit_instantiation module, this diff turns that module into a functor that follows the [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern).//The struct passed in describes how to handle each case in Pierce's algorithm and the `run` function returns a mapping from type param names to the values those functions return.//I was able to replace both users of the module (tests and post-inference run), which got the testing-specific and post-inference-specific code out of the module.//It will be easy to make a new struct to be used during inference when we are further along in the local inference project//Reviewed By: panagosg7//Differential Revision: D26210127//fbshipit-source-id: e9b4c76484e90fce3f474ad6811e994ef993e977",https://github.com/facebook/flow/commit/0854371ab02ddbaf979c37e613e5a913dd477a66,25880891,facebook/flow,False,False
62e39c39ff3cd477466353046d1dadbd1cfb14ee,"BUG#17460821: ASSERTION ERROR WHEN STOPPING SLAVE AFTER SEMI-SYNC ON MASTER IS DISABLED//The assertion happens when: (i) the master and slave are configured to/use the semisync plugin; (ii) the DBA disables semisync on the master;/(iii) and he also unsets the option to wait for slaves ACK even if the/semisync slave count reaches 0 during the waiting period. This/combination of factors makes the server run into an assertion as soon/as the last semisync slave disconnects and its dump thread exits./  /The root of the problem is the fact that when the dump thread/disconnects and calls the observer hook transmit_stop, which ends up/calling ReplSemiSyncMaster::remove_slave, there is no check whether/the master has already disabled semisync or not. If it has, the then a/second call to the switch_off member function must be avoided./  /The quick fix is to avoid calling switch_off if the DBA has disabled/the semisync plugin interactively on the master. Also, the switch_off/member function should only be called if the plugin has not been/switched off already. This is basically the pattern throughout the/rest of the semisync plugin and no other calls seem vulnerable to/similar crashes/assertions.//(This a backport of the patch to 5.5, which is also vulnerable.)",https://github.com/facebook/mysql-5.6/commit/62e39c39ff3cd477466353046d1dadbd1cfb14ee,9454675,facebook/mysql-5.6,False,False
bf325ccd573bba7f7368f1db8baa668afea38c39,"BUG#17460821: ASSERTION ERROR WHEN STOPPING SLAVE AFTER SEMI-SYNC ON MASTER IS DISABLED//The crash happens when: (i) the master and slave are configured to use/the semisync plugin; (ii) the DBA disables semisync on the master;/(iii) and he also unsets the option to wait for slaves ACK even if the/semisync slave count reaches 0 during the waiting period. This/combination of factors makes the server run into an assertion and/crash as soon as the last semisync slave disconnects and its dump/thread exits.//The root of the problem is the fact that when the dump thread/disconnects and calls the observer hook transmit_stop, which ends up/calling ReplSemiSyncMaster::remove_slave, there is no check whether/the master has already disabled semisync or not. If it has, the then a/second call to the switch_off member function must be avoided.//The quick fix is to avoid calling switch_off if the DBA has disabled/the semisync plugin interactively on the master. Also, the switch_off/member function should only be called if the plugin has not been/switched off already. This is basically the pattern throughout the/rest of the semisync plugin and no other calls seem vulnerable to/similar crashes/assertions.",https://github.com/facebook/mysql-5.6/commit/bf325ccd573bba7f7368f1db8baa668afea38c39,9454675,facebook/mysql-5.6,False,False
