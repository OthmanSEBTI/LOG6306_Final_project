sha,message,html_url,repository_id,repository_full_name,repository_private,repository_fork
8b18019e86a5c1ced0f4818633a7b0e482a98a93,"Distinguish Singleton and Caching pattern//Summary: This diff distinguishes Caching pattern from Singleton pattern. Essentially, both patterns writes to (or say, initializes) a global variable when its value is null or does not exist. Yet, it is desired to distinguish if the written global variable is a collection or not: if the assignment directly writes to a collection (e.g. `Foo::$dic[$key] = $value`), then we assume it's a caching; otherwise, it is a singleton (e.g. `Foo::$bar = $x` or `(Foo::$dic[$key])->prop = $y`).//Reviewed By: lavenzg//Differential Revision: D40872670//fbshipit-source-id: 0ec2e66767ef3d1fe241749e4de9607c88222a3e",https://github.com/facebook/hhvm/commit/8b18019e86a5c1ced0f4818633a7b0e482a98a93,455600,facebook/hhvm,False,False
a2bdbd60708599aa3ce226697a5886006b0d95a6,"Recognize coalescing assignment for singleton//Summary: This diff simply recognizes coalescing assignment (of the format `$a ??= $b`) as the ""singleton"" pattern, when the assigned variable is global.//Reviewed By: jamesjwu//Differential Revision: D40763644//fbshipit-source-id: cc84f82b0d8a35e782c5f6e2e08af69baef0cafe",https://github.com/facebook/hhvm/commit/a2bdbd60708599aa3ce226697a5886006b0d95a6,455600,facebook/hhvm,False,False
ef6072246b499377ef3d67923f2f22bf4a568150,"commitcloud: do not make LocalSerivce as a singleton//Summary:/If LocalSerivce is a singleton, it will capture an `ui` object that might be/stale in in-process hg tests. `LocalSerivce` is cheap to construct so let's/just avoid the singleton pattern for test compatibility.//This fixes `test-commitcloud-rename-workspace` debugruntest compatibility as/the following text is now printed properly using the up-to-date `ui.debugflag`://  commitcloud local service: get_references for current version 2//Reviewed By: zzl0//Differential Revision: D42825822//fbshipit-source-id: 683dec345c4a36a6d79080e54a09050991c11dad",https://github.com/facebook/sapling/commit/ef6072246b499377ef3d67923f2f22bf4a568150,58146669,facebook/sapling,False,False
cc5798189f914a7af105f6640c91917b943575fc,"Recognize simple singleton patterns for global writes//Summary:/As suggested by our customer (MI), there are some common patterns for the detected global writes, which are benign in most cases. Thus, this diff introduces the following patterns:/  - Singleton (i.e. write to a global variable whose value is null)/  - CounterIncrement (i.e. increase a global variable by 1 or -1)/  - WriteEmptyOrNUll (i.e. assign null or empty string to a global variable)/  - WriteLiteral (i.e. assign a literal to a global variable)/  - WriteGlobalToGlobal (i.e. assign a global variable to another one)//Currently, all the patterns above are related with global writes, and later some patterns for global reads may be introduced as well.//Specifically, this diff starts with a simple case of the singleton pattern, in which a global object (or its mutable property) is written under the condition that its value is null.//To do:/- Handle a more complex case of the singleton pattern, in which the global object is a collection (e.g. dictionary) and functions like `idx` and `C\contains_key` are used./- To handle other patterns (e.g. WriteLiteral), we will need to track the reference of non-global variables as well. To be more precise, we need a general pointer analyzer, in which the data source of every local variable is maintained (not just the local variables that point to global variables as we do now).//Reviewed By: minjang//Differential Revision: D40181325//fbshipit-source-id: 475ce79d14df7fc2e6df38873a29388394e7d000",https://github.com/facebook/hhvm/commit/cc5798189f914a7af105f6640c91917b943575fc,455600,facebook/hhvm,False,False
28849fee1c3906b3bbdcaa30affe2e8b2d796404,Rename Protocol::fromStandard -> get//Summary: so it is less redundent and better matches exisiting singleton patterns.//Reviewed By: Mizuchi//Differential Revision: D36230963//fbshipit-source-id: 7874d76675079a987e0081c6ecfdd419432ede22,https://github.com/facebook/fbthrift/commit/28849fee1c3906b3bbdcaa30affe2e8b2d796404,11131631,facebook/fbthrift,False,False
f31744a7ae0e81955495541297d0c7b076634271,"Recognize singletons patterns via functions//Summary:/Compared with the previous diff D40181325 that can recognize the simple singleton pattern (in which the value of a global variable is directly checked, e.g. `Foo::$bar is null`), this diff handles some more complex cases, in which functions like `idx` or `C\contains_key` are used to access the elements of global collections.//Limitations:/- If the value of `C\contains_key` is stored in some local variable (instead of directly used in the conditional), then we lose track of the nullable variables./- There could be more functions like `C\contains_key` that checks the existence of some elements in the collection or `idx` that returns the given collection's element, but are not recognized by the current algorithm. If we encounter such functions, we will need to generalize our algorithm by using **an explicit list of such functions**.//Reviewed By: minjang//Differential Revision: D40420507//fbshipit-source-id: fd9ab68bcae827edc281aa332da55262b2b9ae39",https://github.com/facebook/hhvm/commit/f31744a7ae0e81955495541297d0c7b076634271,455600,facebook/hhvm,False,False
db011b8dce61f84a28aff7eb9a3c96884ca55054,"Define an actually empty Empty domain//Summary:/Until now the so-called ""Empty"" domain was actually a singleton domain. We define a new empty domain/that has no element, leveraging an empty ocaml type and unreachable patterns. The singleton domain is/renamed into Unit.//This domain may obviously not be used alone and is to be lifted for instance, with WithBottomTop to/define a ""boolean"" domain.//Note that there was only one occurrence of Empty in the code at/`infer/src/checkers/DisjunctiveDemo.ml`, which seems fine with the new Empty one.//Reviewed By: jvillard//Differential Revision: D39692860//fbshipit-source-id: 139e036d11c52c7f259b238766722f582281ffb8",https://github.com/facebook/infer/commit/db011b8dce61f84a28aff7eb9a3c96884ca55054,29857799,facebook/infer,False,False
407fb5c2384b13abba677789b8d86b21b6ace190,"Implement ability to emit device events from C++ TurboModules//Summary:/[Changelog][Internal]//This adds a method, `emitDeviceEvent` to the C++ API of TurboModules, which allows to make calls to JS's `RCTDeviceEventEmitter.emit` from a C++ TurboModules.//This is a very common pattern, specifically for the VR apps, but not only for them - e.g. Desktop fork also has a [custom implementation for this](https://www.internalfb.com/code/fbsource/third-party/microsoft-fork-of-react-native/react-native-utils/RCTEventEmitter.cpp).//Note that my original intent was to actually backport the latter, however there are some complications with wiring things in a robust way, without exposing too much stuff and relying on singletons or folly::dynamic.//So I ended up adding it to the TurboModule API itself and use the scheduler/JSI facilities instead.//This approach is arguably well self-contained, uses high level APIs, and shouldn't be abusable much.//Since I was trying to avoid usage of folly::dynamic in this case, I used a kind of ""value factory"" pattern instead in order to send the arguments to the JS thread in a thread safe way (see [the discussion here](https://fb.workplace.com/groups/rn.fabric/permalink/1398711453593610/)).//Reviewed By: christophpurrer//Differential Revision: D43466326//fbshipit-source-id: a3cb8359d08a46421559edd0f854772863cb5c39",https://github.com/facebook/react-native/commit/407fb5c2384b13abba677789b8d86b21b6ace190,29028775,facebook/react-native,False,False
769baee7cfc13705e523b25d10a05856ac61e01f,"Type restrictions for value patterns//Summary:/# This diff//The value and singleton patterns implicitly also impose typing restrictions.//Singleton pattern was already working, because it was being translated using `is`, and we handle type refinement with `is`.//The `value` in a value pattern can only be a literal/constant*, so using `is` is equivalent. This diff changes translation of `value` to use `is`.//*The reason the AST uses an expression is that it could either be a one of builtin types' constant (which maps to `Expression.Constant` in the AST) or an enumeration constant (which maps to an attribute in the AST). We add a test in here to make sure refinement is working for enums as well.//# Broader context//See D32027190 (https://github.com/facebook/pyre-check/commit/0d16c9b5206fefc2d00327df9078703eef93f76f).//Reviewed By: pradeep90//Differential Revision: D32624003//fbshipit-source-id: a72c247099c9abbba1d9d428f5e96279e0e250d6",https://github.com/facebook/pyre-check/commit/769baee7cfc13705e523b25d10a05856ac61e01f,110274488,facebook/pyre-check,False,False
af9f0015ea1cb1eeb6c9b775e4c728aefdcd2eee,"MatchTranslate: singleton pattern//Summary:/# This diff//`True`, `False`, and `None` are special and are matched with `is`.//# Context//Locally, starts at: D32455895 (https://github.com/facebook/pyre-check/commit/202d5dabee53599e4480fb72d0a63e83aca2addb); more broadly see D32027190 (https://github.com/facebook/pyre-check/commit/0d16c9b5206fefc2d00327df9078703eef93f76f).//Reviewed By: shannonzhu//Differential Revision: D32572743//fbshipit-source-id: af63b2b38d504c5a26f8a046d6985a37cea19900",https://github.com/facebook/pyre-check/commit/af9f0015ea1cb1eeb6c9b775e4c728aefdcd2eee,110274488,facebook/pyre-check,False,False
72cae4aa80874e09df854e01c432e9ed03d8766b,"Remove special inlining for static property singleton pattern//Summary: No need to special case this pattern, regular inlining can handle it.//Reviewed By: paulbiss//Differential Revision: D15484334//fbshipit-source-id: de2c0811dde0edc58a901bdb37e5686c76ef2625",https://github.com/facebook/hhvm/commit/72cae4aa80874e09df854e01c432e9ed03d8766b,455600,facebook/hhvm,False,False
75ea3dc45bff9c15ca656f30e4ccfe60722c6b65,"Awful bytecode pattern-matcher thing//Summary: I needed something to pattern-match on bytecodes in order to detect and/inline singleton patterns, so here it is.//Reviewed By: jdelong//Differential Revision: D1344595",https://github.com/facebook/hhvm/commit/75ea3dc45bff9c15ca656f30e4ccfe60722c6b65,455600,facebook/hhvm,False,False
3943a732248c4335e0aeb84989ee318e2f426efc,"Fix double-inlining bug w/ singleton inlining//Summary: My singleton inlining machinery assumed that the regular inliner could/never inline singleton patterns.  If this is false, we'll sometimes/inline a function twice, which appears to be happening in practice in/perflab.//I'll try to move the singleton stuff into the new inlining machinery/that I have diffs up for now.//Reviewed By: @bertmaher//Differential Revision: D1412015",https://github.com/facebook/hhvm/commit/3943a732248c4335e0aeb84989ee318e2f426efc,455600,facebook/hhvm,False,False
8ed6ad738c230991eaaab7e656e9d37e5591aa91,"[resolved-env] Correctly compute hint of RHS of assignment using providers//Summary:/Changelog: [internal]//In D36831460 (https://github.com/facebook/flow/commit/e7e380484ba64290ff5102e508e396cd58dc52a6), I attempted to fix the broken hint propagation in assignments. Unfortunately, the fix doesn't really work for two reasons://1. The location we passed to `Env_api.Provider_api.providers_of_def` is the location of an entire assignment, which is not something in the loc_env./2. The identifier expressions we synthesized will be treated as reads, but the locations are write locations.//The problem 2 happened to be hidden by problem 1, and everything appeared to work before because we are incorrectly checking missing-local-annot.//In this diff, I first fixed problem 1 by using the location of LHS pattern./I fixed problem 2 by creating a special kind of hint node: `ProvidersHint`, which takes in a list of provider locations, which will be resolved by querying the type at the write locations in env_resolution. This change makes all the remaining `ValueHint` only takes a singleton list, so I changed `ValueHint` to take a single expression as well. (`ValueHint` is first changed to take a `Nel.t` in D36831460 (https://github.com/facebook/flow/commit/e7e380484ba64290ff5102e508e396cd58dc52a6), but since we determined that the fix is bad, we should revert that).//Reviewed By: mvitousek//Differential Revision: D37369998//fbshipit-source-id: a36d05469b1c4d31ff850963827d79cb3e32ad19",https://github.com/facebook/flow/commit/8ed6ad738c230991eaaab7e656e9d37e5591aa91,25880891,facebook/flow,False,False
c8deadc518a2c08ecda9e5fa6bb3b7ed5707735a,"precedence games w/Singletons//Summary:/Unintended consequences from moving Singleton autoconversion/rules to bottom of pattern match. This moves them just under/union/intersection rules, which gets the job done and fixes/the regressions.//Reviewed By: jeffmo//Differential Revision: D2765429//fb-gh-sync-id: a90ff071c6d173a8909c0bf9cd8a8377d27db759",https://github.com/facebook/flow/commit/c8deadc518a2c08ecda9e5fa6bb3b7ed5707735a,25880891,facebook/flow,False,False
7c3390f7dcf886b0b39acfa505446614641ecb92,"make $Values on a frozen object return singleton literals//Summary:/on a frozen object, StrT, NumT and BoolT values can't be changed so we/can treat them as singletons. this makes this pattern work://```/const Enum = Object.freeze({/  X: 'x',/  Y: 'y',/});/type EnumT = $Values<typeof Enum>/('a': EnumT); // error instead of StrT ~> StrT/```//Reviewed By: avikchaudhuri//Differential Revision: D6232529//fbshipit-source-id: d24339d7a7a607e24a9312d637f83d5c92a97a15",https://github.com/facebook/flow/commit/7c3390f7dcf886b0b39acfa505446614641ecb92,25880891,facebook/flow,False,False
8b5918ee4db4ef8b08a33688bd3bba8ad93ebc87,"demote singleton LB conversion rules//Summary:/Because we use UnionT to represent enums of literals, we're vulnerable/to pathological behavior when big enums are checked against each other/or themselves. The recent addition of an opportunistic membership check/(which fires when an incoming LB is exactly equal to a member of a/UnionT UB) was prevented from firing in many such cases because/unions of literals are represented by collections of Singleton/types, which we currently autoconvert to the corresponding/constrained primitive type when they appear as lower bounds.//As a short term fix, this diff demotes the Singleton conversion/rules by moving them below the UnionT rules in the flow pattern/match. This gives the list membership trap a chance to fire/on the unconverted Singleton ~> UnionT of Singletons type pair.//Longer term, we need to do two things://Reviewed By: avikchaudhuri//Differential Revision: D2764128//fb-gh-sync-id: ef86f11a9118a51049ff8887664ec9125001ffa7",https://github.com/facebook/flow/commit/8b5918ee4db4ef8b08a33688bd3bba8ad93ebc87,25880891,facebook/flow,False,False
9fbf12be2c73617fb22829bb4c02b311346b491d,"Try to inline singleton pattern functions//Summary: We see a lot of code roughly of the form//  function getSingletonFoo() {/    static $instance = null;/    if ($instance === null) {/      // Do some stuff and set $instance./    }/    return $instance;/  }//Let's optimistically assume that such patterns are in fact singleton/patterns (as opposed to, say, some means of inter-method communication/to avoid threading arguments) and try to inline these checks.  The first/time we hit each callsite, we'll side-exit to do the call, and/subsequent calls will simply return the value at $instance, assuming the/checks still pass.//We also introduce a TransFlags struct which we thread through BindJmp/requests and into the translation routines so that we turn the inlining/off in the stub.//Presently, this inlining strategy is restricted to non-resumable/functions with no arguments passed and which don't return refs.//Reviewed By: bertrand//Differential Revision: D1344602",https://github.com/facebook/hhvm/commit/9fbf12be2c73617fb22829bb4c02b311346b491d,455600,facebook/hhvm,False,False
5ae78a0bb6fada9844b9e64402b000b768788c46,"Add utility function to temporarily drop context//Summary:/Same motivation as the last diff (D22050978), we need to provide a way to allow singleton pattern (done through usage of `__Memoize`) at the presence of contexts./This diff adds two helper functions (for async and regular functions) to call a function without any context./Needlessly to say, this is an escape hatch and it should only be used at these specific places where context does not matter. Ideally, it should always call functions that are annotated with `__NoContext`. Making this a runtime enforcement might be useful but I'm not sure if it is necessary.//Reviewed By: paulbiss//Differential Revision: D22121970//fbshipit-source-id: f4f0c7fbc30d3409ca9c0f12283c0693725afbcf",https://github.com/facebook/hhvm/commit/5ae78a0bb6fada9844b9e64402b000b768788c46,455600,facebook/hhvm,False,False
ffdcf1146dce2f5e7f47d9abb5605fa181626a87,"shortcut for negative number literals//Summary:/before, the unary minus operator was handled such that `-x` corresponds to `type of x ~> UnaryMinusT (tout)`, regardless of what `x` is. `__flow` then recognizes the `NumT (Literal) ~> UnaryMinusT` case and multiplies the literal value by -1.//this means that the type of the AST node `-1` is an unresolved tvar rather than a `NumT (Literal -1)`. in a few places, we pattern match on these syntactically generated types directly, rather than via constraints. one such place is when `Object.freeze` generates the resulting object type; if a prop's value type is a `NumT`, we generate a `SingletonNumT`, but if it's an OpenT then we don't. if we don't, then the `NumT` gets summarized to `number` rather than the singleton value.//by example: `let x = Object.freeze({ foo: -1, bar: 2 }); type T = $Values<typeof x>`/the `-1` generates a `NumT ~> UnaryMinusT (tout)`, and the `$Values` generates a `obj ~> GetValuesT`. the latter special cases literal values in frozen objects, but in this case the `tout` is not a literal, even though it will always resolve to exactly one. so we get `type T = number | 2`.//anyway, this diff special cases the unary minus on a number literal to directly create a NumT instead of a tvar, so that the above special case generates a SingletonNumT instead of generalizing.//in this example, now `type T = -1 | 2`//Reviewed By: samwgoldman//Differential Revision: D7506793//fbshipit-source-id: fc995d9c1468ed94bc9744ccb2780e0af7311092",https://github.com/facebook/flow/commit/ffdcf1146dce2f5e7f47d9abb5605fa181626a87,25880891,facebook/flow,False,False
90eb4245c95a1a7c7a59c92cb799e21839cba911,"[hack] Fully expand type variables in Tgenerics//Summary: Typing_expand.fully_expand is used whenever we need to fully expand out any/type variables. One instance where this occurs is making sure we do not store/polymorphic value into a static scoped variable. The reason this is unsound is/demonstrated in the test case I added static_var_no_generic.php//Essientially due to the way static scoped variables, new static(), and/self::method() work, it is possible to trick the type checker that a type/parameter is bound to the improper type. In order to safely use the pattern/in static_var_no_generic.php a type constant should be used instead. Then if we/only know that a type is a ##Singleton## the get method will return an abstract/type.//The reason this is currently not an error is because the ""this"" type is/represented as a generic so we never expand the type variables that are/substituted for its type parameters. That combined with the fact in/don't detect this error case.//Reviewed By: @int3//Differential Revision: D2165262",https://github.com/facebook/flow/commit/90eb4245c95a1a7c7a59c92cb799e21839cba911,25880891,facebook/flow,False,False
a671928b9da749b777e907fc3855a468a08fc543,"Add basic support for configurable partial mode checks//Summary:/HF wants a way to more gradually migrate partial mode files to strict. Doing them per file doesn't match how they work (codemods fixing a certain problem across all files). They would like a mechanism to gradually remove certain problems from being allowed in partial mode.//This diff implements the basic infrastructure for the global configuration, an abstraction to help checking if an error case should be reported, and a single example for testing.//There are some gross things in here. It expands global state with the new configurable list - and it's a singleton no less! Also, the implementations will sprinkle hard-coded error codes around the codebase. Partly this is because the errors are provided from across most of the compiler, so the partial mode checks kind of need to be somewhat global in their scope. Existing implementations do that via global scope, so I continued the pattern rather than making yet another global scope. Also there aren't a whole lot of places that are shared by parser/naming/typing. There aren't any good spots where I could inject logic that knows about both the error codes and the file mode. Threading file mode through the error could would mean touching a few hundred functions (and all of their callsites), whereas changing the strict checks means touching a few dozen callsites.//The hardcoded codes are distasteful, but the error code enums aren't exposed as part of the module. Since that hasn't changed over the lifetime of the codebase, I suspect there's some compelling reason I shouldn't publicize them. Beyond that, the entire point of this exercise is to kill partial mode. Ideally, in a few months we'll be reverting this entire stack. If not, then we can refactor this a bit to make the codes more legible.//Reviewed By: shiqicao, vassilmladenov//Differential Revision: D15470732//fbshipit-source-id: 5bba1daab574552f56327d49c088497fbe654169",https://github.com/facebook/hhvm/commit/a671928b9da749b777e907fc3855a468a08fc543,455600,facebook/hhvm,False,False
6bb640c02927d0c418d46f2318f4fe304fe0d5d3,"Fully expand type variables in Tgenerics//Summary: Typing_expand.fully_expand is used whenever we need to fully expand out any/type variables. One instance where this occurs is making sure we do not store/polymorphic value into a static scoped variable. The reason this is unsound is/demonstrated in the test case I added static_var_no_generic.php//Essientially due to the way static scoped variables, new static(), and/self::method() work, it is possible to trick the type checker that a type/parameter is bound to the improper type. In order to safely use the pattern/in static_var_no_generic.php a type constant should be used instead. Then if we/only know that a type is a ##Singleton## the get method will return an abstract/type.//The reason this is currently not an error is because the ""this"" type is/represented as a generic so we never expand the type variables that are/substituted for its type parameters. That combined with the fact in/don't detect this error case.//Reviewed By: @int3//Differential Revision: D2165262",https://github.com/facebook/hhvm/commit/6bb640c02927d0c418d46f2318f4fe304fe0d5d3,455600,facebook/hhvm,False,False
