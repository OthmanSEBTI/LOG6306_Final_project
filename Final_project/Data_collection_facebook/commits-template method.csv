sha,message,html_url,repository_id,repository_full_name,repository_private,repository_fork
17875005dcd92f239cb5bf939770e43d34b9269b,"Make the base abstract domain class non polymorphic//Summary:/# Context/The base class for all abstract domains is `AbstractDomain`, which uses CRTP, in addition with pure virtual methods to enforce children to implement its interface.//# Problem/Using virtual methods has the downside of making all children classes polymorphic, which means that all instances have to store a virtual table pointer, in addition to their members./This can be costly and is actually never necessary, since `AbstractDomain` also uses CRTP (Curiously Recurring Template Pattern). We would never upcast a children class (say `ConstantAbstractDomain`) into the base class (`AbstractDomain<ConstantAbstractDomain>`) since it is templated by the child class. All virtual calls can actually be resolved statically, since all implementations are marked with `final`.//Also note that each time we wrap an abstract domain in another one, this adds a virtual table pointer. A domain product of N domains will hence have N+1 virtual table pointers (one for each element and one for the top level class).//# Solution/The proposed solution here is to remove all virtual methods from the `AbstractDomain` class, and rely on static asserts to check that children implement the interface properly.//The downside is readability, since static asserts are pretty verbose and require the use of C++ traits./Compiler errors are also worse, since one would now get a static error with obscure traits when forgetting or mistyping a method from the interface, instead of having an error about a missing virtual method./Since sparta aims at speed and performance, I believe this is a necessary cost.//In the future, we could probably use C++ concepts (in C++20) for better readability.//Reviewed By: arnaudvenet//Differential Revision: D45236059//fbshipit-source-id: 78b7f73252465f0f4c4430815697016d3a7d32de",https://github.com/facebook/mariana-trench/commit/17875005dcd92f239cb5bf939770e43d34b9269b,317710554,facebook/mariana-trench,False,False
e3844c5dca777bdadbaa2e7118904239049f062c,"Make the base abstract domain class non polymorphic//Summary:/# Context/The base class for all abstract domains is `AbstractDomain`, which uses CRTP, in addition with pure virtual methods to enforce children to implement its interface.//# Problem/Using virtual methods has the downside of making all children classes polymorphic, which means that all instances have to store a virtual table pointer, in addition to their members./This can be costly and is actually never necessary, since `AbstractDomain` also uses CRTP (Curiously Recurring Template Pattern). We would never upcast a children class (say `ConstantAbstractDomain`) into the base class (`AbstractDomain<ConstantAbstractDomain>`) since it is templated by the child class. All virtual calls can actually be resolved statically, since all implementations are marked with `final`.//Also note that each time we wrap an abstract domain in another one, this adds a virtual table pointer. A domain product of N domains will hence have N+1 virtual table pointers (one for each element and one for the top level class).//# Solution/The proposed solution here is to remove all virtual methods from the `AbstractDomain` class, and rely on static asserts to check that children implement the interface properly.//The downside is readability, since static asserts are pretty verbose and require the use of C++ traits./Compiler errors are also worse, since one would now get a static error with obscure traits when forgetting or mistyping a method from the interface, instead of having an error about a missing virtual method./Since sparta aims at speed and performance, I believe this is a necessary cost.//In the future, we could probably use C++ concepts (in C++20) for better readability.//Reviewed By: arnaudvenet//Differential Revision: D45236059//fbshipit-source-id: 78b7f73252465f0f4c4430815697016d3a7d32de",https://github.com/facebook/SPARTA/commit/e3844c5dca777bdadbaa2e7118904239049f062c,132040907,facebook/SPARTA,False,False
e63392938400904ce979468349cabf2940abf690,"Make the base abstract domain class non polymorphic//Summary:/# Context/The base class for all abstract domains is `AbstractDomain`, which uses CRTP, in addition with pure virtual methods to enforce children to implement its interface.//# Problem/Using virtual methods has the downside of making all children classes polymorphic, which means that all instances have to store a virtual table pointer, in addition to their members./This can be costly and is actually never necessary, since `AbstractDomain` also uses CRTP (Curiously Recurring Template Pattern). We would never upcast a children class (say `ConstantAbstractDomain`) into the base class (`AbstractDomain<ConstantAbstractDomain>`) since it is templated by the child class. All virtual calls can actually be resolved statically, since all implementations are marked with `final`.//Also note that each time we wrap an abstract domain in another one, this adds a virtual table pointer. A domain product of N domains will hence have N+1 virtual table pointers (one for each element and one for the top level class).//# Solution/The proposed solution here is to remove all virtual methods from the `AbstractDomain` class, and rely on static asserts to check that children implement the interface properly.//The downside is readability, since static asserts are pretty verbose and require the use of C++ traits./Compiler errors are also worse, since one would now get a static error with obscure traits when forgetting or mistyping a method from the interface, instead of having an error about a missing virtual method./Since sparta aims at speed and performance, I believe this is a necessary cost.//In the future, we could probably use C++ concepts (in C++20) for better readability.//Reviewed By: arnaudvenet//Differential Revision: D45236059//fbshipit-source-id: 78b7f73252465f0f4c4430815697016d3a7d32de",https://github.com/facebook/redex/commit/e63392938400904ce979468349cabf2940abf690,54664770,facebook/redex,False,False
362a8172b648514a5d1f66cb03d9ce9745507d37,"Unhack generator option handling//Summary:/`t_generation_context` consists of generator output options and a source manager with the manager added there only to avoid changing numerous generator ctors. Now that the latter is not a problem add source manager as a parameter to the generator ctor where it should be, move output options to `process_options` and remove `t_generation_context`. Apply the template method pattern to `process_options` to guarantee that some options are always handled by the base generator and processing of the rest can be overridden by subclasses.//Remove `thrift/compiler/test/t_mstch_generator_test.cc` which doesn't add a lot of value.//And finally rename (the inverse of) `is_out_path_absolute` to `add_gen_dir` because this option has nothing to do with absolute paths. It controls whether to add `gen-<name>` directory to the output directory.//Reviewed By: avalonalex//Differential Revision: D38812260//fbshipit-source-id: 07070a3b9122fd53a4b59408fa8f1aa5c4ebc6b5",https://github.com/facebook/fbthrift/commit/362a8172b648514a5d1f66cb03d9ce9745507d37,11131631,facebook/fbthrift,False,False
e9dd65bffabdfbc7bd1883cca4c61a676cdf7499,"FPushCuf: Optimize the case where callable is an (obj, staticstr)//The pattern call_user_func(array($obj, ""staticString""), ...)/is pretty common, and it's basically the same as FPushObjMethodD/except it warns instead of fataling when the method is not defined./Catch this pattern and turn it into a similar IR sequence, and add a/template flag to methodCacheSlowPath to warn instead of fataling.//Reviewed By: @swtaarrs//Differential Revision: D1042143",https://github.com/facebook/hhvm/commit/e9dd65bffabdfbc7bd1883cca4c61a676cdf7499,455600,facebook/hhvm,False,False
47280de85e62f33f0b97bc1ed7c83bc6ca0dc7d4,"New Props parsing infrastructure for perf improvements: visitor pattern vs random-map-access pattern (ViewProps, minus YogaLayoutableShadowNode)//Summary:/Perf numbers for this stack are given in terms of before-stack and after-stack, but the changes are split up for ease of review, and also to show that this migration CAN happen per-component and is 100% opt-in. Most existing C++ components do not /need/ to change at all.//# Problem Statement//During certain renders (select critical scenarios in specific products), UIManagerBinding::createNode time takes over 50% of JS thread CPU time. This could be higher or lower depending on the specific product and interaction, but overall createNode takes a lot of CPU time. The question is: can we improve this? What is the minimal overhead needed?//The vast, vast majority of time is taken up by prop parsing (specifically, converting JS values across the JSI into concrete values on the C++ props structs). Other methods like appendChild, etc, do not take up a significant amount of time; so we conclude that createNode is special, and the JSI itself, or calling into C++, is not the problem. Props parsing is the perf problem.//Can we improve it? (Spoiler: yes)//# How does props parsing work today?//Today, props parsing works as follows://1. The ConcreteComponentDescriptor will construct a RawPropsParser (one per component /type/, per application: so one for View, one for Image, one for Text... etc)/2. Once per component type per application, ConcreteComponentDescriptor will call ""prepare"" on the RawPropsParser with an empty, default-constructed ConcreteProps struct. This ConcreteProps struct will cause RawProps.at(field) for every single field./3. Based on the RawProps::at calls in part 2, RawPropsParser constructs a Map from props string names (width, height, position, etc) to a position within a ""value index"" array./4. The above is what happens before any actual props are parsed; and the RawPropsParser is now ready to parse actual Props./5. When props are actually being parsed from a JSI dictionary, we now have two phases:/  1. The RawPropsParser `preparse`s the RawProps, by iterating over the JSI map and filling in two additional data structures: a linear list of RawValues, and a mapping from the ValueIndex array (`keyIndexToValueIndex_`; see step 3) to a value's position in the values list (`value_` in RawPropsParser/RawProps);/  2. The ConcretePropT constructor is called, which is the same as in step 2/3, which calls `fieldValue = rawProps.at(""fieldName"")` repeatedly./  3. For each `at` call, the RawProps will look up a prop name in the Map constructed in step 3, and either return an empty value, or map the key name to the `keyIndexToValueIndex_` array, which maps to a value in `values_`, which is then returned and further parsed.//So, a few things that become clear with the current architecture://1. Complexity is a property of the number of /possible/ props that /can/ be parsed, not what is actually used in product code. This violates the ""only pay for what you use"" principal. If you have `<View opacity={0.5} />`, the ViewProps constructor will request ~170 properties, not 1!/2. There's a lot of pre-parsing which isn't free/3. The levels of indirection aren't free, and make cache misses more likely and pipelining is more challenging/4. The levels of indirection also require more memory - minor, but not free//# How can we improve it?//The goal is to improve props parsing with minimal or zero impact on backwards-compability. We should be able to migrate over components when it's clear there's a performance issue, without requiring everything gets migrated over at once. This both (1) helps us prove out the new architecture, (2) derisks the project, (3) gives us time, internally and externally, to perfect the APIs and gradually migrate everything over before deleting the old infrastructure code entirely.//Thus, the goal is to do something that introduces a zero-cost abstraction. This isn't entirely possible in practice, and in fact this method slightly regresses components that do not use the new architecture /at all/, while dramatically improving migrated components and causing the impact of the /old/ architecture to be minimal.//# Solution//1. We still keep the existing system in place entirely./2. After Props are constructed (see ConcreteComponentDescriptor changes) we iterate over all the /values/ set from JS, and call PropsT::setProp. Incidentally, this allows us to easily reuse the same prop for multiple values for ""free"", which was expensive in the old system./3. It's worth noting that this makes a Props struct ""less immutable"" than it was before, and essentially now we have a ""builder pattern"" for Props. (If we really wanted to, we could still require a single constructor for Props, and then actually use an intermediate PropsBuilder to accumulate values - but I don't think this overhead would be worth for the conceptual ""immutability"" win, and instead a ""Construct/Set/Seal"" model works fine, and we still have all the same guarantees of immutability after the parsing phase)//# Implementation Details/# How to properly construct a single Prop value//Minor detail: parsing a single prop is a 3-step process. We imagine two scenarios: (1) Creating a new ShadowNode/Props A from nothing/void, so the previous Props value is just the default constructor. (2) Cloning a ShadowNode A->B and therefore Props A must be copied to Props B before parsing.//We will denote this as a clone from A->B, where A may or may not be a previous node or a default-constructed Props node; and imagine in particular that we're setting the ""opacity"" value for PropsB.//We must first (1) copy a value over from the previous version of the Props struct, so B.opacity = A.opacity; (2) Determine if opacity has been set from JS. If so, and there is a value, B.opacity = parse(JSValue). (3) If JS has passed in a value for the prop, BUT the value is `null`, it means that JS is resetting or deleting the prop, so we must set it BACK to the default. In this case we set PropsB.opacity = DefaultConstructedProps.opacity.//We must take care in general to ensure that the correct behavior is achieved here, which should help to explain some of the code below.//## String comparisons vs hash comparisons//In the previous system, a RawPropsKey is three `const char*` strings, concatenated together repeatedly /at runtime/. In practice, the ONLY reason we have the prefix, name, suffix Key structure is for the templated prop parsing in ViewProps and YogaStyableProps - that's it. It's not used anywhere else. Further, the key {""margin"", ""Left"", ""Width""} is identical to the key {""marginLeftWidth"", null, null} and we don't do anything fancy with matching prefixes before comparing the whole string, or similar. Before comparison, keys are concatenated into a single string and then we use `strcmp`. The performance of this isn't terrible, but it's nonzero overhead.//I think we can do better and it's sufficient to compare hashed string values; even better, we can construct most of these /at compile time/ using constexpr, and using `switch` statements guarantee no hash collisions within a single Props struct (it's possible there's a collision between Props.cpp and ViewProps.cpp, for example, since they're different switch statements). We may eventually want to be more robust against has collisions; I personally don't find the risk to be too great, hash collisions with these keys are exceedingly unlikely (or maybe I just like to live dangerously). Thus, at runtime, each setProp requires computing a single hash for the value coming from JS, and then int comparisons with a bunch of pre-compiled values.//If we want to be really paranoid, we could be robust to hash collisions by doing `switch COMPILED_HASH(""opacity""): if (strcmp(strFromJs, ""opacity"") == 0)`. I'm happy to do this if there's enough concern.//## Macros//Yuck! I'm using lots of C preprocessor macros. In general I found this way, way easier in reducing code and (essentially) doing codegen for me vs templated code for the switch cases and hashing prop names at compile-time. Maybe there's a better way.//Changelog: [Added][Fabric] New API for efficient props construction//Reviewed By: javache//Differential Revision: D37050215//fbshipit-source-id: d2dcd351a93b9715cfeb5197eb0d6f9194ec6eb9",https://github.com/facebook/react-native/commit/47280de85e62f33f0b97bc1ed7c83bc6ca0dc7d4,29028775,facebook/react-native,False,False
